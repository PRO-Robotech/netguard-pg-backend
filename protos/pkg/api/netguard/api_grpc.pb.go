// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: netguard/api.proto

package netguard

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	NetguardService_Sync_FullMethodName                         = "/netguard.v1.NetguardService/Sync"
	NetguardService_SyncStatus_FullMethodName                   = "/netguard.v1.NetguardService/SyncStatus"
	NetguardService_ListServices_FullMethodName                 = "/netguard.v1.NetguardService/ListServices"
	NetguardService_ListAddressGroups_FullMethodName            = "/netguard.v1.NetguardService/ListAddressGroups"
	NetguardService_ListAddressGroupBindings_FullMethodName     = "/netguard.v1.NetguardService/ListAddressGroupBindings"
	NetguardService_ListAddressGroupPortMappings_FullMethodName = "/netguard.v1.NetguardService/ListAddressGroupPortMappings"
	NetguardService_ListRuleS2S_FullMethodName                  = "/netguard.v1.NetguardService/ListRuleS2S"
)

// NetguardServiceClient is the client API for NetguardService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service definition
type NetguardServiceClient interface {
	// Sync - syncs data in DB
	Sync(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SyncStatus - gets last succeeded update DB status
	SyncStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SyncStatusResp, error)
	// ListServices - gets list of services
	ListServices(ctx context.Context, in *ListServicesReq, opts ...grpc.CallOption) (*ListServicesResp, error)
	// ListAddressGroups - gets list of address groups
	ListAddressGroups(ctx context.Context, in *ListAddressGroupsReq, opts ...grpc.CallOption) (*ListAddressGroupsResp, error)
	// ListAddressGroupBindings - gets list of address group bindings
	ListAddressGroupBindings(ctx context.Context, in *ListAddressGroupBindingsReq, opts ...grpc.CallOption) (*ListAddressGroupBindingsResp, error)
	// ListAddressGroupPortMappings - gets list of address group port mappings
	ListAddressGroupPortMappings(ctx context.Context, in *ListAddressGroupPortMappingsReq, opts ...grpc.CallOption) (*ListAddressGroupPortMappingsResp, error)
	// ListRuleS2S - gets list of rule s2s
	ListRuleS2S(ctx context.Context, in *ListRuleS2SReq, opts ...grpc.CallOption) (*ListRuleS2SResp, error)
}

type netguardServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNetguardServiceClient(cc grpc.ClientConnInterface) NetguardServiceClient {
	return &netguardServiceClient{cc}
}

func (c *netguardServiceClient) Sync(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NetguardService_Sync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netguardServiceClient) SyncStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SyncStatusResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncStatusResp)
	err := c.cc.Invoke(ctx, NetguardService_SyncStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netguardServiceClient) ListServices(ctx context.Context, in *ListServicesReq, opts ...grpc.CallOption) (*ListServicesResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListServicesResp)
	err := c.cc.Invoke(ctx, NetguardService_ListServices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netguardServiceClient) ListAddressGroups(ctx context.Context, in *ListAddressGroupsReq, opts ...grpc.CallOption) (*ListAddressGroupsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAddressGroupsResp)
	err := c.cc.Invoke(ctx, NetguardService_ListAddressGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netguardServiceClient) ListAddressGroupBindings(ctx context.Context, in *ListAddressGroupBindingsReq, opts ...grpc.CallOption) (*ListAddressGroupBindingsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAddressGroupBindingsResp)
	err := c.cc.Invoke(ctx, NetguardService_ListAddressGroupBindings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netguardServiceClient) ListAddressGroupPortMappings(ctx context.Context, in *ListAddressGroupPortMappingsReq, opts ...grpc.CallOption) (*ListAddressGroupPortMappingsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAddressGroupPortMappingsResp)
	err := c.cc.Invoke(ctx, NetguardService_ListAddressGroupPortMappings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *netguardServiceClient) ListRuleS2S(ctx context.Context, in *ListRuleS2SReq, opts ...grpc.CallOption) (*ListRuleS2SResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRuleS2SResp)
	err := c.cc.Invoke(ctx, NetguardService_ListRuleS2S_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetguardServiceServer is the server API for NetguardService service.
// All implementations must embed UnimplementedNetguardServiceServer
// for forward compatibility.
//
// Service definition
type NetguardServiceServer interface {
	// Sync - syncs data in DB
	Sync(context.Context, *SyncReq) (*emptypb.Empty, error)
	// SyncStatus - gets last succeeded update DB status
	SyncStatus(context.Context, *emptypb.Empty) (*SyncStatusResp, error)
	// ListServices - gets list of services
	ListServices(context.Context, *ListServicesReq) (*ListServicesResp, error)
	// ListAddressGroups - gets list of address groups
	ListAddressGroups(context.Context, *ListAddressGroupsReq) (*ListAddressGroupsResp, error)
	// ListAddressGroupBindings - gets list of address group bindings
	ListAddressGroupBindings(context.Context, *ListAddressGroupBindingsReq) (*ListAddressGroupBindingsResp, error)
	// ListAddressGroupPortMappings - gets list of address group port mappings
	ListAddressGroupPortMappings(context.Context, *ListAddressGroupPortMappingsReq) (*ListAddressGroupPortMappingsResp, error)
	// ListRuleS2S - gets list of rule s2s
	ListRuleS2S(context.Context, *ListRuleS2SReq) (*ListRuleS2SResp, error)
	mustEmbedUnimplementedNetguardServiceServer()
}

// UnimplementedNetguardServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNetguardServiceServer struct{}

func (UnimplementedNetguardServiceServer) Sync(context.Context, *SyncReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sync not implemented")
}
func (UnimplementedNetguardServiceServer) SyncStatus(context.Context, *emptypb.Empty) (*SyncStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncStatus not implemented")
}
func (UnimplementedNetguardServiceServer) ListServices(context.Context, *ListServicesReq) (*ListServicesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListServices not implemented")
}
func (UnimplementedNetguardServiceServer) ListAddressGroups(context.Context, *ListAddressGroupsReq) (*ListAddressGroupsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAddressGroups not implemented")
}
func (UnimplementedNetguardServiceServer) ListAddressGroupBindings(context.Context, *ListAddressGroupBindingsReq) (*ListAddressGroupBindingsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAddressGroupBindings not implemented")
}
func (UnimplementedNetguardServiceServer) ListAddressGroupPortMappings(context.Context, *ListAddressGroupPortMappingsReq) (*ListAddressGroupPortMappingsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAddressGroupPortMappings not implemented")
}
func (UnimplementedNetguardServiceServer) ListRuleS2S(context.Context, *ListRuleS2SReq) (*ListRuleS2SResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRuleS2S not implemented")
}
func (UnimplementedNetguardServiceServer) mustEmbedUnimplementedNetguardServiceServer() {}
func (UnimplementedNetguardServiceServer) testEmbeddedByValue()                         {}

// UnsafeNetguardServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetguardServiceServer will
// result in compilation errors.
type UnsafeNetguardServiceServer interface {
	mustEmbedUnimplementedNetguardServiceServer()
}

func RegisterNetguardServiceServer(s grpc.ServiceRegistrar, srv NetguardServiceServer) {
	// If the following call pancis, it indicates UnimplementedNetguardServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NetguardService_ServiceDesc, srv)
}

func _NetguardService_Sync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetguardServiceServer).Sync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetguardService_Sync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetguardServiceServer).Sync(ctx, req.(*SyncReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetguardService_SyncStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetguardServiceServer).SyncStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetguardService_SyncStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetguardServiceServer).SyncStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetguardService_ListServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServicesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetguardServiceServer).ListServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetguardService_ListServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetguardServiceServer).ListServices(ctx, req.(*ListServicesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetguardService_ListAddressGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAddressGroupsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetguardServiceServer).ListAddressGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetguardService_ListAddressGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetguardServiceServer).ListAddressGroups(ctx, req.(*ListAddressGroupsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetguardService_ListAddressGroupBindings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAddressGroupBindingsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetguardServiceServer).ListAddressGroupBindings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetguardService_ListAddressGroupBindings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetguardServiceServer).ListAddressGroupBindings(ctx, req.(*ListAddressGroupBindingsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetguardService_ListAddressGroupPortMappings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAddressGroupPortMappingsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetguardServiceServer).ListAddressGroupPortMappings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetguardService_ListAddressGroupPortMappings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetguardServiceServer).ListAddressGroupPortMappings(ctx, req.(*ListAddressGroupPortMappingsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetguardService_ListRuleS2S_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRuleS2SReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetguardServiceServer).ListRuleS2S(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetguardService_ListRuleS2S_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetguardServiceServer).ListRuleS2S(ctx, req.(*ListRuleS2SReq))
	}
	return interceptor(ctx, in, info, handler)
}

// NetguardService_ServiceDesc is the grpc.ServiceDesc for NetguardService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetguardService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "netguard.v1.NetguardService",
	HandlerType: (*NetguardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Sync",
			Handler:    _NetguardService_Sync_Handler,
		},
		{
			MethodName: "SyncStatus",
			Handler:    _NetguardService_SyncStatus_Handler,
		},
		{
			MethodName: "ListServices",
			Handler:    _NetguardService_ListServices_Handler,
		},
		{
			MethodName: "ListAddressGroups",
			Handler:    _NetguardService_ListAddressGroups_Handler,
		},
		{
			MethodName: "ListAddressGroupBindings",
			Handler:    _NetguardService_ListAddressGroupBindings_Handler,
		},
		{
			MethodName: "ListAddressGroupPortMappings",
			Handler:    _NetguardService_ListAddressGroupPortMappings_Handler,
		},
		{
			MethodName: "ListRuleS2S",
			Handler:    _NetguardService_ListRuleS2S_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "netguard/api.proto",
}
