package services

import (
	"context"
	"crypto/sha256"
	"fmt"
	"log"
	"sort"
	"strings"
	"time"

	"k8s.io/klog/v2"

	"netguard-pg-backend/internal/application/validation"
	"netguard-pg-backend/internal/domain/models"
	"netguard-pg-backend/internal/domain/ports"
	"netguard-pg-backend/internal/k8s/apis/netguard/v1beta1"
	"netguard-pg-backend/internal/sync/interfaces"
	"netguard-pg-backend/internal/sync/types"

	"github.com/pkg/errors"
)

// NetguardService provides operations for managing netguard resources
type NetguardService struct {
	registry              ports.Registry
	conditionManager      *ConditionManager
	syncManager           interfaces.SyncManager
	networkService        *NetworkService
	networkBindingService *NetworkBindingService
}

// NewNetguardService creates a new NetguardService
func NewNetguardService(registry ports.Registry, syncManager interfaces.SyncManager) *NetguardService {
	s := &NetguardService{
		registry:    registry,
		syncManager: syncManager,
	}
	s.conditionManager = NewConditionManager(registry, s)
	s.networkService = NewNetworkService(registry, syncManager)
	s.networkBindingService = NewNetworkBindingService(registry, s.networkService, syncManager)
	return s
}

// GetServices returns all services
func (s *NetguardService) GetServices(ctx context.Context, scope ports.Scope) ([]models.Service, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var services []models.Service
	err = reader.ListServices(ctx, func(service models.Service) error {
		services = append(services, service)
		return nil
	}, scope)
	if err != nil {
		return nil, errors.Wrap(err, "failed to list services")
	}
	return services, nil
}

// GetAddressGroups returns all address groups
func (s *NetguardService) GetAddressGroups(ctx context.Context, scope ports.Scope) ([]models.AddressGroup, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var addressGroups []models.AddressGroup
	err = reader.ListAddressGroups(ctx, func(addressGroup models.AddressGroup) error {
		addressGroups = append(addressGroups, addressGroup)
		return nil
	}, scope)
	if err != nil {
		return nil, errors.Wrap(err, "failed to list address groups")
	}
	return addressGroups, nil
}

// GetAddressGroupBindings returns all address group bindings
func (s *NetguardService) GetAddressGroupBindings(ctx context.Context, scope ports.Scope) ([]models.AddressGroupBinding, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var bindings []models.AddressGroupBinding
	err = reader.ListAddressGroupBindings(ctx, func(binding models.AddressGroupBinding) error {
		bindings = append(bindings, binding)
		return nil
	}, scope)
	if err != nil {
		return nil, errors.Wrap(err, "failed to list address group bindings")
	}
	return bindings, nil
}

// GetAddressGroupPortMappings returns all address group port mappings
func (s *NetguardService) GetAddressGroupPortMappings(ctx context.Context, scope ports.Scope) ([]models.AddressGroupPortMapping, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var mappings []models.AddressGroupPortMapping
	err = reader.ListAddressGroupPortMappings(ctx, func(mapping models.AddressGroupPortMapping) error {
		mappings = append(mappings, mapping)
		return nil
	}, scope)
	if err != nil {
		return nil, errors.Wrap(err, "failed to list address group port mappings")
	}
	return mappings, nil
}

// GetRuleS2S returns all rule s2s
func (s *NetguardService) GetRuleS2S(ctx context.Context, scope ports.Scope) ([]models.RuleS2S, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var rules []models.RuleS2S
	err = reader.ListRuleS2S(ctx, func(rule models.RuleS2S) error {
		rules = append(rules, rule)
		return nil
	}, scope)
	if err != nil {
		return nil, errors.Wrap(err, "failed to list rule s2s")
	}
	return rules, nil
}

// GetServiceAliases returns all service aliases
func (s *NetguardService) GetServiceAliases(ctx context.Context, scope ports.Scope) ([]models.ServiceAlias, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var aliases []models.ServiceAlias
	err = reader.ListServiceAliases(ctx, func(alias models.ServiceAlias) error {
		aliases = append(aliases, alias)
		return nil
	}, scope)
	if err != nil {
		return nil, errors.Wrap(err, "failed to list service aliases")
	}
	return aliases, nil
}

// GetAddressGroupBindingPolicies returns all address group binding policies
func (s *NetguardService) GetAddressGroupBindingPolicies(ctx context.Context, scope ports.Scope) ([]models.AddressGroupBindingPolicy, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var policies []models.AddressGroupBindingPolicy
	err = reader.ListAddressGroupBindingPolicies(ctx, func(policy models.AddressGroupBindingPolicy) error {
		policies = append(policies, policy)
		return nil
	}, scope)
	if err != nil {
		return nil, errors.Wrap(err, "failed to list address group binding policies")
	}
	return policies, nil
}

// GetNetworks returns all networks
func (s *NetguardService) GetNetworks(ctx context.Context, scope ports.Scope) ([]models.Network, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var networks []models.Network
	err = reader.ListNetworks(ctx, func(network models.Network) error {
		networks = append(networks, network)
		return nil
	}, scope)
	if err != nil {
		return nil, errors.Wrap(err, "failed to list networks")
	}
	return networks, nil
}

// GetNetworkBindings returns all network bindings
func (s *NetguardService) GetNetworkBindings(ctx context.Context, scope ports.Scope) ([]models.NetworkBinding, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var bindings []models.NetworkBinding
	err = reader.ListNetworkBindings(ctx, func(binding models.NetworkBinding) error {
		bindings = append(bindings, binding)
		return nil
	}, scope)
	if err != nil {
		return nil, errors.Wrap(err, "failed to list network bindings")
	}
	return bindings, nil
}

// CreateService —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —Å–µ—Ä–≤–∏—Å
func (s *NetguardService) CreateService(ctx context.Context, service models.Service) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	serviceValidator := validator.GetServiceValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º —Å–µ—Ä–≤–∏—Å –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º
	if err := serviceValidator.ValidateForCreation(ctx, service); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncServices(ctx, []models.Service{service}, ports.NewResourceIdentifierScope(service.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to create service")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
	s.processConditionsIfNeeded(ctx, &service, models.SyncOpUpsert)
	return nil
}

// CreateAddressGroup —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –≥—Ä—É–ø–ø—É –∞–¥—Ä–µ—Å–æ–≤
func (s *NetguardService) CreateAddressGroup(ctx context.Context, addressGroup models.AddressGroup) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	addressGroupValidator := validator.GetAddressGroupValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –≥—Ä—É–ø–ø—É –∞–¥—Ä–µ—Å–æ–≤ –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º
	if err := addressGroupValidator.ValidateForCreation(ctx, addressGroup); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncAddressGroups(ctx, []models.AddressGroup{addressGroup}, ports.NewResourceIdentifierScope(addressGroup.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to create address group")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å sgroups –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è –≤ –ë–î
	s.syncAddressGroupsWithSGroups(ctx, []models.AddressGroup{addressGroup}, types.SyncOperationUpsert)

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
	s.processConditionsIfNeeded(ctx, &addressGroup, models.SyncOpUpsert)
	return nil
}

// UpdateService –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Å–µ—Ä–≤–∏—Å
func (s *NetguardService) UpdateService(ctx context.Context, service models.Service) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é —Å–µ—Ä–≤–∏—Å–∞
	oldService, err := reader.GetServiceByID(ctx, service.ResourceIdentifier)
	if err != nil {
		return errors.Wrap(err, "failed to get existing service")
	}

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	serviceValidator := validator.GetServiceValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º —Å–µ—Ä–≤–∏—Å –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
	if err := serviceValidator.ValidateForUpdate(ctx, *oldService, service); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncServices(ctx, []models.Service{service}, ports.NewResourceIdentifierScope(service.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to update service")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
	s.processConditionsIfNeeded(ctx, &service, models.SyncOpUpsert)
	return nil
}

// UpdateAddressGroup –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –≥—Ä—É–ø–ø—É –∞–¥—Ä–µ—Å–æ–≤
func (s *NetguardService) UpdateAddressGroup(ctx context.Context, addressGroup models.AddressGroup) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤
	oldAddressGroup, err := reader.GetAddressGroupByID(ctx, addressGroup.ResourceIdentifier)
	if err != nil {
		return errors.Wrap(err, "failed to get existing address group")
	}

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	addressGroupValidator := validator.GetAddressGroupValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –≥—Ä—É–ø–ø—É –∞–¥—Ä–µ—Å–æ–≤ –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
	if err := addressGroupValidator.ValidateForUpdate(ctx, *oldAddressGroup, addressGroup); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncAddressGroups(ctx, []models.AddressGroup{addressGroup}, ports.NewResourceIdentifierScope(addressGroup.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to update address group")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å sgroups –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤ –ë–î
	s.syncAddressGroupsWithSGroups(ctx, []models.AddressGroup{addressGroup}, types.SyncOperationUpsert)

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
	s.processConditionsIfNeeded(ctx, &addressGroup, models.SyncOpUpsert)
	return nil
}

// CreateAddressGroupBinding —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –ø—Ä–∏–≤—è–∑–∫—É –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤
func (s *NetguardService) CreateAddressGroupBinding(ctx context.Context, binding models.AddressGroupBinding) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	bindingValidator := validator.GetAddressGroupBindingValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –ø—Ä–∏–≤—è–∑–∫—É –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º
	if err := bindingValidator.ValidateForCreation(ctx, &binding); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncAddressGroupBindings(ctx, []models.AddressGroupBinding{binding}, ports.NewResourceIdentifierScope(binding.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to create address group binding")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	// –û–±—Ä–∞–±–æ—Ç–∫–∞ conditions
	s.conditionManager.ProcessAddressGroupBindingConditions(ctx, &binding)
	if err := s.conditionManager.saveResourceConditions(ctx, &binding); err != nil {
		return errors.Wrap(err, "failed to save address group binding conditions")
	}
	return nil
}

// UpdateAddressGroupBinding –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ø—Ä–∏–≤—è–∑–∫—É –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤
func (s *NetguardService) UpdateAddressGroupBinding(ctx context.Context, binding models.AddressGroupBinding) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é –ø—Ä–∏–≤—è–∑–∫–∏
	oldBinding, err := reader.GetAddressGroupBindingByID(ctx, binding.ResourceIdentifier)
	if err != nil {
		return errors.Wrap(err, "failed to get existing address group binding")
	}

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	bindingValidator := validator.GetAddressGroupBindingValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –ø—Ä–∏–≤—è–∑–∫—É –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
	if err := bindingValidator.ValidateForUpdate(ctx, *oldBinding, &binding); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncAddressGroupBindings(ctx, []models.AddressGroupBinding{binding}, ports.NewResourceIdentifierScope(binding.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to update address group binding")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	s.conditionManager.ProcessAddressGroupBindingConditions(ctx, &binding)
	if err := s.conditionManager.saveResourceConditions(ctx, &binding); err != nil {
		return errors.Wrap(err, "failed to save address group binding conditions")
	}
	return nil
}

// Sync –≤—ã–ø–æ–ª–Ω—è–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π –∏ —Å—É–±—ä–µ–∫—Ç–æ–º
func (s *NetguardService) Sync(ctx context.Context, syncOp models.SyncOp, subject interface{}) error {
	klog.Infof("üî• DEBUG: MAIN Sync called with syncOp=%s, subject type=%T", syncOp, subject)
	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Å—É–±—ä–µ–∫—Ç–æ–≤
	klog.Infof("üî• DEBUG: MAIN Sync starting switch statement for type %T", subject)
	switch v := subject.(type) {
	case []models.Service:
		klog.Infof("üî• DEBUG: MAIN Sync matched []models.Service case with %d services, syncOp=%s", len(v), syncOp)
		for i, service := range v {
			klog.Infof("üî• DEBUG: MAIN Sync Service[%d]: %s, ports=%d", i, service.Key(), len(service.IngressPorts))
		}
		if err := s.syncServices(ctx, writer, v, syncOp); err != nil {
			return err
		}
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
		s.processConditionsIfNeeded(ctx, v, syncOp)
		return nil
	case []models.AddressGroup:
		if err := s.syncAddressGroups(ctx, writer, v, syncOp); err != nil {
			return err
		}
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
		s.processConditionsIfNeeded(ctx, v, syncOp)
		return nil
	case []models.AddressGroupBinding:
		if err := s.syncAddressGroupBindings(ctx, writer, v, syncOp); err != nil {
			return err
		}
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
		s.processConditionsIfNeeded(ctx, v, syncOp)
		return nil
	case []models.AddressGroupPortMapping:
		if err := s.syncAddressGroupPortMappings(ctx, writer, v, syncOp); err != nil {
			return err
		}
		// Commit —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
		if err := writer.Commit(); err != nil {
			return errors.Wrap(err, "failed to commit")
		}
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
		s.processConditionsIfNeeded(ctx, v, syncOp)
		return nil
	case []models.RuleS2S:
		if err := s.syncRuleS2S(ctx, writer, v, syncOp); err != nil {
			return err
		}
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
		s.processConditionsIfNeeded(ctx, v, syncOp)
		return nil
	case []models.ServiceAlias:
		if err := s.syncServiceAliases(ctx, writer, v, syncOp); err != nil {
			return err
		}
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
		s.processConditionsIfNeeded(ctx, v, syncOp)
		return nil
	case []models.AddressGroupBindingPolicy:
		if err := s.syncAddressGroupBindingPolicies(ctx, writer, v, syncOp); err != nil {
			return err
		}
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
		s.processConditionsIfNeeded(ctx, v, syncOp)
		return nil
	case []models.Network:
		if err := s.syncNetworks(ctx, writer, v, syncOp); err != nil {
			return err
		}
		// NOTE: We do NOT call processConditionsIfNeeded here because syncNetworks
		// already handles conditions processing with sgroups sync results
		return nil
	case []models.NetworkBinding:
		if err := s.syncNetworkBindings(ctx, writer, v, syncOp); err != nil {
			return err
		}
		// NOTE: We do NOT call processConditionsIfNeeded here because syncNetworkBindings
		// already handles condition processing within the same transaction.
		// Calling it here would create a separate commit that overwrites our atomic changes.
		return nil
	case []models.IEAgAgRule:
		klog.Infof("üî• DEBUG: DANGER! General Sync processing %d IEAgAgRules bypassing port aggregation!", len(v))
		for i, rule := range v {
			klog.Infof("üî• DEBUG: IEAgAgRule[%d]: %s, ports: %s", i, rule.Key(), rule.Ports[0].Destination)
		}
		klog.Infof("üî• DEBUG: STACK TRACE: This bypasses port aggregation logic!")
		if err := s.syncIEAgAgRules(ctx, writer, v, syncOp); err != nil {
			return err
		}
		// NOTE: syncIEAgAgRules already handles sgroups sync and conditions processing
		return nil
	default:
		return errors.New("unsupported subject type")
	}
}

// processConditionsIfNeeded –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç conditions —Ç–æ–ª—å–∫–æ –¥–ª—è –Ω–µ-—É–¥–∞–ª–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π
func (s *NetguardService) processConditionsIfNeeded(ctx context.Context, subject interface{}, syncOp models.SyncOp) {
	// –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É conditions –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π —É–¥–∞–ª–µ–Ω–∏—è
	if syncOp == models.SyncOpDelete {
		return
	}

	switch v := subject.(type) {
	case []models.Service:
		for i := range v {
			s.conditionManager.ProcessServiceConditions(ctx, &v[i])
			if err := s.conditionManager.saveResourceConditions(ctx, &v[i]); err != nil {
				log.Printf("Failed to save service conditions for %s: %v", v[i].Key(), err)
			}
		}
	case []models.AddressGroup:
		for i := range v {
			s.conditionManager.ProcessAddressGroupConditions(ctx, &v[i])
			if err := s.conditionManager.saveResourceConditions(ctx, &v[i]); err != nil {
				log.Printf("Failed to save address group conditions for %s: %v", v[i].Key(), err)
			}
		}
	case []models.AddressGroupBinding:
		for i := range v {
			s.conditionManager.ProcessAddressGroupBindingConditions(ctx, &v[i])
			if err := s.conditionManager.saveResourceConditions(ctx, &v[i]); err != nil {
				log.Printf("Failed to save address group binding conditions for %s: %v", v[i].Key(), err)
			}
		}
	case []models.AddressGroupPortMapping:
		for i := range v {
			s.conditionManager.ProcessAddressGroupPortMappingConditions(ctx, &v[i])
			if err := s.conditionManager.saveResourceConditions(ctx, &v[i]); err != nil {
				log.Printf("Failed to save address group port mapping conditions for %s: %v", v[i].Key(), err)
			}
		}
	case []models.RuleS2S:
		for i := range v {
			s.conditionManager.ProcessRuleS2SConditions(ctx, &v[i])
			if err := s.conditionManager.saveResourceConditions(ctx, &v[i]); err != nil {
				log.Printf("Failed to save rule s2s conditions for %s: %v", v[i].Key(), err)
			}
		}
	case []models.ServiceAlias:
		for i := range v {
			s.conditionManager.ProcessServiceAliasConditions(ctx, &v[i])
			if err := s.conditionManager.saveResourceConditions(ctx, &v[i]); err != nil {
				log.Printf("Failed to save service alias conditions for %s: %v", v[i].Key(), err)
			}
		}
	case []models.AddressGroupBindingPolicy:
		for i := range v {
			s.conditionManager.ProcessAddressGroupBindingPolicyConditions(ctx, &v[i])
			if err := s.conditionManager.saveResourceConditions(ctx, &v[i]); err != nil {
				log.Printf("Failed to save address group binding policy conditions for %s: %v", v[i].Key(), err)
			}
		}
	case []models.Network:
		// –í–ê–ñ–ù–û: –î–ª—è Network –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º processConditionsIfNeeded!
		// –£—Å–ª–æ–≤–∏—è –¥–ª—è Network –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –≤ syncNetworks/SyncNetworks
		// —Å —É—á–µ—Ç–æ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ sgroups. –≠—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç race condition
		// –∏ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏.
		return
	case []models.NetworkBinding:
		for i := range v {
			s.conditionManager.ProcessNetworkBindingConditions(ctx, &v[i])
			if err := s.conditionManager.saveResourceConditions(ctx, &v[i]); err != nil {
				log.Printf("Failed to save network binding conditions for %s: %v", v[i].Key(), err)
			}
		}
	case *models.AddressGroupPortMapping:
		s.conditionManager.ProcessAddressGroupPortMappingConditions(ctx, v)
		if err := s.conditionManager.saveResourceConditions(ctx, v); err != nil {
			log.Printf("Failed to save address group port mapping conditions for %s: %v", v.Key(), err)
		}
	default:
		// Unknown subject type - no conditions processing needed
	}
}

// CreateAddressGroupPortMapping —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –º–∞–ø–ø–∏–Ω–≥ –ø–æ—Ä—Ç–æ–≤ –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤
func (s *NetguardService) CreateAddressGroupPortMapping(ctx context.Context, mapping models.AddressGroupPortMapping) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	mappingValidator := validator.GetAddressGroupPortMappingValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –º–∞–ø–ø–∏–Ω–≥ –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º
	if err := mappingValidator.ValidateForCreation(ctx, mapping); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncAddressGroupPortMappings(ctx, []models.AddressGroupPortMapping{mapping}, ports.NewResourceIdentifierScope(mapping.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to create address group port mapping")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
	s.processConditionsIfNeeded(ctx, &mapping, models.SyncOpUpsert)
	return nil
}

// UpdateAddressGroupPortMapping –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –º–∞–ø–ø–∏–Ω–≥ –ø–æ—Ä—Ç–æ–≤ –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤
func (s *NetguardService) UpdateAddressGroupPortMapping(ctx context.Context, mapping models.AddressGroupPortMapping) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é –º–∞–ø–ø–∏–Ω–≥–∞
	oldMapping, err := reader.GetAddressGroupPortMappingByID(ctx, mapping.ResourceIdentifier)
	if err != nil {
		return errors.Wrap(err, "failed to get existing address group port mapping")
	}

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	mappingValidator := validator.GetAddressGroupPortMappingValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –º–∞–ø–ø–∏–Ω–≥ –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
	if err := mappingValidator.ValidateForUpdate(ctx, *oldMapping, mapping); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncAddressGroupPortMappings(ctx, []models.AddressGroupPortMapping{mapping}, ports.NewResourceIdentifierScope(mapping.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to update address group port mapping")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
	s.processConditionsIfNeeded(ctx, &mapping, models.SyncOpUpsert)
	return nil
}

// syncServices —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç —Å–µ—Ä–≤–∏—Å—ã —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
func (s *NetguardService) syncServices(ctx context.Context, writer ports.Writer, services []models.Service, syncOp models.SyncOp) error {
	klog.Infof("üî• DEBUG: syncServices called with %d services, syncOp=%s", len(services), syncOp)
	for i, service := range services {
		klog.Infof("üî• DEBUG: Service[%d]: %s, ports=%d", i, service.Key(), len(service.IngressPorts))
		for j, port := range service.IngressPorts {
			klog.Infof("üî• DEBUG: Service[%d].IngressPorts[%d]: %s/%s", i, j, port.Port, port.Protocol)
		}
	}
	// Get reader for validation and comparison
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
	if syncOp != models.SyncOpDelete {
		validator := validation.NewDependencyValidator(reader)
		serviceValidator := validator.GetServiceValidator()

		for _, service := range services {
			existingService, err := reader.GetServiceByID(ctx, service.ResourceIdentifier)
			if err == nil && syncOp != models.SyncOpDelete {
				// –°–µ—Ä–≤–∏—Å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForUpdate
				if err := serviceValidator.ValidateForUpdate(ctx, *existingService, service); err != nil {
					return err
				}
			} else if err == ports.ErrNotFound && syncOp != models.SyncOpDelete {
				// –°–µ—Ä–≤–∏—Å –Ω–æ–≤—ã–π - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForCreation
				if err := serviceValidator.ValidateForCreation(ctx, service); err != nil {
					return err
				}
			} else if err != nil && err != ports.ErrNotFound {
				// –ü—Ä–æ–∏–∑–æ—à–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞
				return errors.Wrap(err, "failed to get service")
			}
		}
	}

	// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ scope
	var scope ports.Scope
	if syncOp == models.SyncOpFullSync {
		// –ü—Ä–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ FullSync –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Å—Ç—É—é –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏,
		// —á—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã, –∞ –∑–∞—Ç–µ–º –¥–æ–±–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ
		scope = ports.EmptyScope{}
	} else if len(services) > 0 {
		var ids []models.ResourceIdentifier
		for _, service := range services {
			ids = append(ids, service.ResourceIdentifier)
		}
		scope = ports.NewResourceIdentifierScope(ids...)
	} else {
		scope = ports.EmptyScope{}
	}

	// –ï—Å–ª–∏ —ç—Ç–æ —É–¥–∞–ª–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º DeleteServicesByIDs –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –∫–∞—Å–∫–∞–¥–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è
	if syncOp == models.SyncOpDelete {
		// –°–æ–±–∏—Ä–∞–µ–º ID —Å–µ—Ä–≤–∏—Å–æ–≤
		var ids []models.ResourceIdentifier
		for _, service := range services {
			ids = append(ids, service.ResourceIdentifier)
		}

		// –ò—Å–ø–æ–ª—å–∑—É–µ–º DeleteServicesByIDs –¥–ª—è –∫–∞—Å–∫–∞–¥–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤ –∏ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
		return s.DeleteServicesByIDs(ctx, ids)
	}

	// –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø—Ü–∏–µ–π –¥–ª—è –Ω–µ-—É–¥–∞–ª–µ–Ω–∏—è
	if err := writer.SyncServices(ctx, services, scope, ports.WithSyncOp(syncOp)); err != nil {
		return errors.Wrap(err, "failed to sync services")
	}

	// –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —É–¥–∞–ª–µ–Ω–∏–µ, –æ–±–Ω–æ–≤–ª—è–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã
	var allNewIEAgAgRules []models.IEAgAgRule
	if syncOp != models.SyncOpDelete {
		// OPTIMIZATION: Only update IEAgAgRules for services with changed ports
		var servicesWithPortDiffs []ServicePortDiff
		for _, service := range services {
			// Get existing service for comparison using the original reader (sees old state)
			existingService, err := reader.GetServiceByID(ctx, service.ResourceIdentifier)
			if err != nil {
				// New service - add to update list
				log.Printf("syncServices: Service %s is new, will update related IEAgAgRules", service.Key())
				servicePortDiff := ServicePortDiff{
					ServiceID:    service.ResourceIdentifier,
					AddedPorts:   service.IngressPorts,   // –≤—Å–µ –ø–æ—Ä—Ç—ã —Å—á–∏—Ç–∞—é—Ç—Å—è –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–º–∏
					RemovedPorts: []models.IngressPort{}, // –Ω–∏—á–µ–≥–æ –Ω–µ —É–¥–∞–ª–µ–Ω–æ
					IsNewService: true,
				}
				servicesWithPortDiffs = append(servicesWithPortDiffs, servicePortDiff)
				continue
			}

			// Compare ports between old and new version using detailed diff
			addedPorts, removedPorts := CompareServicePorts(existingService.IngressPorts, service.IngressPorts)
			if len(addedPorts) > 0 || len(removedPorts) > 0 {
				servicePortDiff := ServicePortDiff{
					ServiceID:    service.ResourceIdentifier,
					AddedPorts:   addedPorts,
					RemovedPorts: removedPorts,
					IsNewService: false,
				}
				servicesWithPortDiffs = append(servicesWithPortDiffs, servicePortDiff)
				log.Printf("syncServices: Service %s has changed ports, added: %v, removed: %v",
					service.Key(), addedPorts, removedPorts)
			} else {
				log.Printf("syncServices: Service %s ports unchanged, skipping IEAgAgRule update", service.Key())
			}
		}

		// Update IEAgAgRules and Port Mapping only for services with changed ports
		if len(servicesWithPortDiffs) > 0 {
			log.Printf("syncServices: Found %d services with changed ports, updating related IEAgAgRules", len(servicesWithPortDiffs))

			// Get reader that can see changes in current transaction
			txReader, err := s.registry.ReaderFromWriter(ctx, writer)
			if err != nil {
				return errors.Wrap(err, "failed to get transaction reader")
			}
			defer txReader.Close()

			// 1. –û–±–Ω–æ–≤–ª—è–µ–º IE AG AG –ø—Ä–∞–≤–∏–ª–∞
			// –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ RuleS2S, –∫–æ—Ç–æ—Ä—ã–µ —Å—Å—ã–ª–∞—é—Ç—Å—è –Ω–∞ —Å–µ—Ä–≤–∏—Å—ã —Å –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–º–∏ –ø–æ—Ä—Ç–∞–º–∏
			var changedServiceIDs []models.ResourceIdentifier
			for _, portDiff := range servicesWithPortDiffs {
				changedServiceIDs = append(changedServiceIDs, portDiff.ServiceID)
			}
			affectedRules, err := s.findRuleS2SForServicesWithReader(ctx, txReader, changedServiceIDs)
			if err != nil {
				return errors.Wrap(err, "failed to find affected RuleS2S")
			}

			log.Printf("syncServices: Found %d RuleS2S affected by port changes", len(affectedRules))

			// –û–±–Ω–æ–≤–ª—è–µ–º IE AG AG –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –∑–∞—Ç—Ä–æ–Ω—É—Ç—ã—Ö RuleS2S, –∏—Å–ø–æ–ª—å–∑—É—è reader –∏–∑ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
			// –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–µ—Ä—Å–∏—é —Å –∞–≥—Ä–µ–≥–∞—Ü–∏–µ–π –ø–æ—Ä—Ç–æ–≤ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è
			if len(affectedRules) > 0 {
				klog.Infof("üî• DEBUG: syncServices calling updateIEAgAgRulesForRuleS2SWithReader with %d rules", len(affectedRules))
				if err = s.updateIEAgAgRulesForRuleS2SWithReader(ctx, writer, txReader, affectedRules, models.SyncOpFullSync); err != nil {
					return errors.Wrap(err, "failed to update IEAgAgRules for affected RuleS2S")
				}
				klog.Infof("üî• DEBUG: syncServices completed updateIEAgAgRulesForRuleS2SWithReader successfully")

				// Get all IEAgAgRules from DB for conditions processing (after aggregation)
				err = txReader.ListIEAgAgRules(ctx, func(ieRule models.IEAgAgRule) error {
					allNewIEAgAgRules = append(allNewIEAgAgRules, ieRule)
					return nil
				}, nil)
				if err != nil {
					return errors.Wrap(err, "failed to list all IEAgAgRules for conditions processing")
				}
				log.Printf("syncServices: Found %d IEAgAgRules for conditions processing", len(allNewIEAgAgRules))
			}

			// 2. –û–±–Ω–æ–≤–ª—è–µ–º Port Mapping —Ç–æ–ª—å–∫–æ –¥–ª—è —Å–µ—Ä–≤–∏—Å–æ–≤ —Å –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–º–∏ –ø–æ—Ä—Ç–∞–º–∏
			// –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –ø—Ä–∏–≤—è–∑–∫–∏ AddressGroupBinding –¥–ª—è —Å–µ—Ä–≤–∏—Å–æ–≤ —Å –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–º–∏ –ø–æ—Ä—Ç–∞–º–∏
			var bindings []models.AddressGroupBinding
			err = txReader.ListAddressGroupBindings(ctx, func(binding models.AddressGroupBinding) error {
				for _, serviceID := range changedServiceIDs {
					if binding.ServiceRef.Key() == serviceID.Key() {
						bindings = append(bindings, binding)
						break
					}
				}
				return nil
			}, nil)

			if err != nil {
				return errors.Wrap(err, "failed to list address group bindings")
			}

			// –û–±–Ω–æ–≤–ª—è–µ–º Port Mapping –¥–ª—è –∫–∞–∂–¥–æ–π –ø—Ä–∏–≤—è–∑–∫–∏, –∏—Å–ø–æ–ª—å–∑—É—è reader –∏–∑ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
			for _, binding := range bindings {
				if err := s.SyncAddressGroupPortMappingsWithWriterAndReader(ctx, writer, txReader, binding, models.SyncOpFullSync); err != nil {
					return errors.Wrapf(err, "failed to sync port mapping for binding %s", binding.Key())
				}
			}
		} else {
			log.Printf("syncServices: No services with changed ports found, skipping IEAgAgRule updates")
		}
	}

	if err := writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// Process conditions for IEAGAG rules created during service sync (now with proper port aggregation)
	for i := range allNewIEAgAgRules {
		if err := s.conditionManager.ProcessIEAgAgRuleConditions(ctx, &allNewIEAgAgRules[i]); err != nil {
			log.Printf("Failed to process IEAgAgRule conditions for %s: %v", allNewIEAgAgRules[i].Key(), err)
		}
		if err := s.conditionManager.saveResourceConditions(ctx, &allNewIEAgAgRules[i]); err != nil {
			log.Printf("Failed to save IEAgAgRule conditions for %s: %v", allNewIEAgAgRules[i].Key(), err)
		}
	}

	return nil
}

// CreateRuleS2S —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤–æ–µ –ø—Ä–∞–≤–∏–ª–æ s2s
func (s *NetguardService) CreateRuleS2S(ctx context.Context, rule models.RuleS2S) error {
	log.Printf("CreateRuleS2S: Starting creation of RuleS2S %s", rule.Key())

	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	ruleValidator := validator.GetRuleS2SValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –ø—Ä–∞–≤–∏–ª–æ –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º
	log.Printf("CreateRuleS2S: Validating RuleS2S %s", rule.Key())
	if err := ruleValidator.ValidateForCreation(ctx, rule); err != nil {
		log.Printf("CreateRuleS2S: Validation failed for RuleS2S %s: %v", rule.Key(), err)
		return err
	}
	log.Printf("CreateRuleS2S: Validation passed for RuleS2S %s", rule.Key())

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			log.Printf("CreateRuleS2S: Aborting transaction for RuleS2S %s due to error: %v", rule.Key(), err)
			writer.Abort()
		}
	}()

	// –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º syncRuleS2S –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ IEAgAgRule –∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è IEAgAgRuleRefs
	log.Printf("CreateRuleS2S: Syncing RuleS2S %s with IEAgAgRule generation", rule.Key())
	if err = s.syncRuleS2S(ctx, writer, []models.RuleS2S{rule}, models.SyncOpUpsert); err != nil {
		log.Printf("CreateRuleS2S: Failed to sync RuleS2S %s: %v", rule.Key(), err)
		return errors.Wrap(err, "failed to create rule s2s")
	}

	if err = writer.Commit(); err != nil {
		log.Printf("CreateRuleS2S: Failed to commit transaction for RuleS2S %s: %v", rule.Key(), err)
		return errors.Wrap(err, "failed to commit")
	}
	log.Printf("CreateRuleS2S: Successfully committed RuleS2S %s", rule.Key())

	// –û–±—Ä–∞–±–æ—Ç–∫–∞ conditions
	log.Printf("CreateRuleS2S: Processing conditions for RuleS2S %s", rule.Key())
	s.conditionManager.ProcessRuleS2SConditions(ctx, &rule)
	if err := s.conditionManager.saveResourceConditions(ctx, &rule); err != nil {
		log.Printf("CreateRuleS2S: Failed to save conditions for RuleS2S %s: %v", rule.Key(), err)
		return errors.Wrap(err, "failed to save rule s2s conditions")
	}

	log.Printf("CreateRuleS2S: Successfully created RuleS2S %s", rule.Key())
	return nil
}

// UpdateRuleS2S –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ –ø—Ä–∞–≤–∏–ª–æ s2s
func (s *NetguardService) UpdateRuleS2S(ctx context.Context, rule models.RuleS2S) error {
	log.Printf("UpdateRuleS2S: Starting update of RuleS2S %s", rule.Key())

	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é –ø—Ä–∞–≤–∏–ª–∞
	log.Printf("UpdateRuleS2S: Fetching existing RuleS2S %s", rule.Key())
	oldRule, err := reader.GetRuleS2SByID(ctx, rule.ResourceIdentifier)
	if err != nil {
		log.Printf("UpdateRuleS2S: Failed to get existing RuleS2S %s: %v", rule.Key(), err)
		return errors.Wrap(err, "failed to get existing rule s2s")
	}
	log.Printf("UpdateRuleS2S: Found existing RuleS2S %s with %d IEAgAgRuleRefs",
		oldRule.Key(), len(oldRule.IEAgAgRuleRefs))

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	ruleValidator := validator.GetRuleS2SValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –ø—Ä–∞–≤–∏–ª–æ –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
	log.Printf("UpdateRuleS2S: Validating update of RuleS2S %s", rule.Key())
	if err := ruleValidator.ValidateForUpdate(ctx, *oldRule, rule); err != nil {
		log.Printf("UpdateRuleS2S: Validation failed for RuleS2S %s: %v", rule.Key(), err)
		return err
	}
	log.Printf("UpdateRuleS2S: Validation passed for RuleS2S %s", rule.Key())

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			log.Printf("UpdateRuleS2S: Aborting transaction for RuleS2S %s due to error: %v", rule.Key(), err)
			writer.Abort()
		}
	}()

	// –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º syncRuleS2S –¥–ª—è –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è IEAgAgRule –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è IEAgAgRuleRefs
	log.Printf("UpdateRuleS2S: Syncing RuleS2S %s with IEAgAgRule regeneration", rule.Key())
	if err = s.syncRuleS2S(ctx, writer, []models.RuleS2S{rule}, models.SyncOpUpsert); err != nil {
		log.Printf("UpdateRuleS2S: Failed to sync RuleS2S %s: %v", rule.Key(), err)
		return errors.Wrap(err, "failed to update rule s2s")
	}

	if err = writer.Commit(); err != nil {
		log.Printf("UpdateRuleS2S: Failed to commit transaction for RuleS2S %s: %v", rule.Key(), err)
		return errors.Wrap(err, "failed to commit")
	}
	log.Printf("UpdateRuleS2S: Successfully committed RuleS2S %s", rule.Key())

	// –û–±—Ä–∞–±–æ—Ç–∫–∞ conditions
	log.Printf("UpdateRuleS2S: Processing conditions for RuleS2S %s", rule.Key())
	s.conditionManager.ProcessRuleS2SConditions(ctx, &rule)
	if err := s.conditionManager.saveResourceConditions(ctx, &rule); err != nil {
		log.Printf("UpdateRuleS2S: Failed to save conditions for RuleS2S %s: %v", rule.Key(), err)
		return errors.Wrap(err, "failed to save rule s2s conditions")
	}

	log.Printf("UpdateRuleS2S: Successfully updated RuleS2S %s", rule.Key())
	return nil
}

// findRuleS2SForServices finds all RuleS2S that reference the given services
func (s *NetguardService) findRuleS2SForServices(ctx context.Context, serviceIDs []models.ResourceIdentifier) ([]models.RuleS2S, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	return s.findRuleS2SForServicesWithReader(ctx, reader, serviceIDs)
}

// findRuleS2SForServicesWithReader finds all RuleS2S that reference the given services using the provided reader
func (s *NetguardService) findRuleS2SForServicesWithReader(ctx context.Context, reader ports.Reader, serviceIDs []models.ResourceIdentifier) ([]models.RuleS2S, error) {
	// First, find all ServiceAliases that reference these services
	var serviceAliases []models.ServiceAlias
	err := reader.ListServiceAliases(ctx, func(alias models.ServiceAlias) error {
		for _, serviceID := range serviceIDs {
			if alias.ServiceRef.Key() == serviceID.Key() {
				serviceAliases = append(serviceAliases, alias)
				break
			}
		}
		return nil
	}, nil)

	if err != nil {
		return nil, errors.Wrap(err, "failed to list service aliases")
	}

	// Create a map of service alias IDs for quick lookup
	serviceAliasMap := make(map[string]bool)
	for _, alias := range serviceAliases {
		serviceAliasMap[alias.Key()] = true
	}

	// Now find all RuleS2S that reference these service aliases
	var rules []models.RuleS2S
	err = reader.ListRuleS2S(ctx, func(rule models.RuleS2S) error {
		// Check if the rule references any of the service aliases
		if serviceAliasMap[rule.ServiceLocalRef.Key()] || serviceAliasMap[rule.ServiceRef.Key()] {
			rules = append(rules, rule)
		}
		return nil
	}, nil)

	if err != nil {
		return nil, errors.Wrap(err, "failed to list rules")
	}

	return rules, nil
}

// // updateIEAgAgRulesForRuleS2S updates the IEAgAgRules for the given RuleS2S
// // syncOp - –æ–ø–µ—Ä–∞—Ü–∏—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ (FullSync, Upsert, Delete)
// func (s *NetguardService) updateIEAgAgRulesForRuleS2S(ctx context.Context, writer ports.Writer, rules []models.RuleS2S, syncOp models.SyncOp) error {
// 	// Get all existing IEAgAgRules to detect obsolete ones
// 	reader, err := s.registry.Reader(ctx)
// 	if err != nil {
// 		return errors.Wrap(err, "failed to get reader")
// 	}
// 	defer reader.Close()

// 	return s.updateIEAgAgRulesForRuleS2SWithReader(ctx, writer, reader, rules, syncOp)
// }

// // updateIEAgAgRulesForRuleS2SWithReaderNoConditions updates the IEAgAgRules for the given RuleS2S using the provided reader without processing conditions
// // This version is used when conditions will be processed separately (e.g., in syncServices)
// // syncOp - –æ–ø–µ—Ä–∞—Ü–∏—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ (FullSync, Upsert, Delete)
// func (s *NetguardService) updateIEAgAgRulesForRuleS2SWithReaderNoConditions(ctx context.Context, writer ports.Writer, reader ports.Reader, rules []models.RuleS2S, syncOp models.SyncOp) error {
// 	// Get all existing IEAgAgRules to detect obsolete ones
// 	existingRules := make(map[string]models.IEAgAgRule)
// 	err := reader.ListIEAgAgRules(ctx, func(rule models.IEAgAgRule) error {
// 		existingRules[rule.Key()] = rule
// 		return nil
// 	}, nil)

// 	if err != nil {
// 		return errors.Wrap(err, "failed to list existing IEAgAgRules")
// 	}

// 	// Create a map of expected rules after the update
// 	expectedRules := make(map[string]bool)
// 	var allNewRules []models.IEAgAgRule

// 	// Generate IEAgAgRules for each RuleS2S
// 	for _, rule := range rules {
// 		ieAgAgRules, err := s.GenerateIEAgAgRulesFromRuleS2SWithReader(ctx, reader, rule)
// 		if err != nil {
// 			return errors.Wrapf(err, "failed to generate IEAgAgRules for RuleS2S %s", rule.Key())
// 		}

// 		// Add generated rules to the expected rules map and collect all new rules
// 		for _, ieRule := range ieAgAgRules {
// 			expectedRules[ieRule.Key()] = true
// 			allNewRules = append(allNewRules, ieRule)
// 		}
// 	}

// 	// Sync all new rules at once WITH sgroups synchronization
// 	if len(allNewRules) > 0 {
// 		if err = s.syncIEAgAgRules(ctx, writer, allNewRules, syncOp); err != nil {
// 			return errors.Wrap(err, "failed to sync new IEAgAgRules")
// 		}
// 	}

// 	// Find and delete obsolete rules
// 	var obsoleteRules []models.IEAgAgRule
// 	for key, rule := range existingRules {
// 		if !expectedRules[key] {
// 			obsoleteRules = append(obsoleteRules, rule)
// 		}
// 	}

// 	if len(obsoleteRules) > 0 {
// 		klog.Infof("üóëÔ∏è NO_CONDITIONS: Deleting %d obsolete IEAgAgRules", len(obsoleteRules))

// 		// üìã STEP 1: Log all obsolete rules that will be deleted
// 		for i, rule := range obsoleteRules {
// 			klog.Infof("  üóëÔ∏è OBSOLETE[%d]: %s (%s/%s %s‚Üí%s ports=%s)",
// 				i, rule.Key(), rule.Transport, rule.Traffic,
// 				rule.AddressGroupLocal.Key(), rule.AddressGroup.Key(),
// 				rule.Ports[0].Destination)
// 		}

// 		// üöÄ STEP 2: CRITICAL - Sync DELETE operation with sgroups FIRST!
// 		klog.Infof("üîÑ NO_CONDITIONS: Syncing DELETE operation with sgroups for %d obsolete rules", len(obsoleteRules))
// 		if err = s.syncIEAgAgRules(ctx, writer, obsoleteRules, models.SyncOpDelete); err != nil {
// 			klog.Errorf("‚ùå NO_CONDITIONS: Failed to sync obsolete rules deletion with sgroups: %v", err)
// 			return errors.Wrap(err, "failed to sync obsolete IEAgAgRules deletion with sgroups")
// 		}
// 		klog.Infof("‚úÖ NO_CONDITIONS: Successfully synced DELETE operation with sgroups")

// 		// üìã STEP 3: Delete from database AFTER sgroups sync
// 		var obsoleteRuleIDs []models.ResourceIdentifier
// 		for _, rule := range obsoleteRules {
// 			obsoleteRuleIDs = append(obsoleteRuleIDs, rule.ResourceIdentifier)
// 		}

// 		klog.Infof("üóÉÔ∏è NO_CONDITIONS: Deleting %d obsolete rules from database", len(obsoleteRuleIDs))
// 		if err = writer.DeleteIEAgAgRulesByIDs(ctx, obsoleteRuleIDs); err != nil {
// 			klog.Errorf("‚ùå NO_CONDITIONS: Failed to delete obsolete rules from database: %v", err)
// 			return errors.Wrap(err, "failed to delete obsolete IEAgAgRules from database")
// 		}
// 		klog.Infof("‚úÖ NO_CONDITIONS: Successfully deleted %d obsolete rules from database", len(obsoleteRuleIDs))
// 	} else {
// 		klog.Infof("‚úÖ NO_CONDITIONS: No obsolete rules to delete")
// 	}

// 	return nil
// }

// updateIEAgAgRulesForRuleS2SWithReader updates the IEAgAgRules using SERVICE-CENTRIC approach
// This new implementation aggregates rules by affected services to prevent duplicates
// syncOp - –æ–ø–µ—Ä–∞—Ü–∏—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ (FullSync, Upsert, Delete)
func (s *NetguardService) updateIEAgAgRulesForRuleS2SWithReader(ctx context.Context, writer ports.Writer, reader ports.Reader, rules []models.RuleS2S, syncOp models.SyncOp) error {
	klog.Infof("üöÄ SERVICE_CENTRIC: updateIEAgAgRulesForRuleS2SWithReader called with %d RuleS2S, syncOp=%s", len(rules), syncOp)
	
	// STEP 1: Identify all affected services from the input RuleS2S
	affectedServices := make(map[string]models.ResourceIdentifier)
	
	for i, rule := range rules {
		klog.Infof("üîç SERVICE_CENTRIC: Processing RuleS2S[%d]: %s (traffic=%s, local=%s, target=%s)",
			i, rule.Key(), rule.Traffic, rule.ServiceLocalRef.Key(), rule.ServiceRef.Key())
		
		// Get services referenced by this rule
		localService, err := reader.GetServiceByAlias(ctx, rule.ServiceLocalRef.ResourceIdentifier)
		if err != nil {
			klog.Errorf("‚ùå SERVICE_CENTRIC: Failed to get local service %s: %v", rule.ServiceLocalRef.Key(), err)
			continue
		}
		
		targetService, err := reader.GetServiceByAlias(ctx, rule.ServiceRef.ResourceIdentifier)
		if err != nil {
			klog.Errorf("‚ùå SERVICE_CENTRIC: Failed to get target service %s: %v", rule.ServiceRef.Key(), err)
			continue
		}
		
		// Add both services to affected services map
		affectedServices[localService.Key()] = localService.ResourceIdentifier
		affectedServices[targetService.Key()] = targetService.ResourceIdentifier
		
		klog.Infof("  ‚úÖ SERVICE_CENTRIC: Added affected services - local: %s, target: %s",
			localService.Key(), targetService.Key())
	}
	
	klog.Infof("üéØ SERVICE_CENTRIC: Found %d unique affected services", len(affectedServices))
	
	// STEP 2: For each affected service, regenerate ALL its related IEAgAg rules
	return s.updateIEAgAgRulesForAffectedServices(ctx, writer, reader, affectedServices, syncOp)
}

// updateIEAgAgRulesForAffectedServices regenerates IEAgAg rules for all affected services
func (s *NetguardService) updateIEAgAgRulesForAffectedServices(ctx context.Context, writer ports.Writer, reader ports.Reader, affectedServices map[string]models.ResourceIdentifier, syncOp models.SyncOp) error {
	klog.Infof("üîÑ SERVICE_REBUILD: Processing %d affected services", len(affectedServices))
	
	// TEST: Use new ListAllRelatedRuleS2S function
	for serviceKey, serviceID := range affectedServices {
		klog.Infof("üîç SERVICE_REBUILD: Testing ListAllRelatedRuleS2S for service %s", serviceKey)
		
		relatedRules, err := s.backendClient.ListAllRelatedRuleS2S(ctx, serviceID)
		if err != nil {
			klog.Errorf("‚ùå SERVICE_REBUILD: Failed to find related rules for service %s: %v", serviceKey, err)
			continue
		}
		
		klog.Infof("üéØ SERVICE_REBUILD: Found %d related RuleS2S for service %s", len(relatedRules), serviceKey)
		for _, rule := range relatedRules {
			klog.Infof("  üìã SERVICE_REBUILD: Related rule: %s", rule.Key())
		}
	}
	
	// TODO: Complete implementation later
	klog.Infof("‚ö†Ô∏è  SERVICE_REBUILD: Full implementation in progress...")
	return nil
}



// TODO: Implement helper functions for service-centric approach

// SyncServices syncs services
func (s *NetguardService) SyncServices(ctx context.Context, services []models.Service, scope ports.Scope) error {
	// TODO: Implement proper service synchronization
	klog.Infof("SyncServices called with %d services", len(services))
	return nil
}

// syncAddressGroups —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
func (s *NetguardService) syncAddressGroups(ctx context.Context, writer ports.Writer, addressGroups []models.AddressGroup, syncOp models.SyncOp) error {
	// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
	if syncOp != models.SyncOpDelete {
		reader, err := s.registry.Reader(ctx)
		if err != nil {
			return errors.Wrap(err, "failed to get reader")
		}
		defer reader.Close()

					klog.Infof("üîç FULL_AGGREGATION: Processing AG group[%d,%d] %s ‚Üí %s (%s %s)",
						i, j, localAG.Key(), targetAG.Key(), rule.Traffic, protocol)

					// üî• CRITICAL: Check if the relevant service has ports for this traffic direction
					var relevantService models.Service
					var relevantServiceName string
					if rule.Traffic == models.INGRESS {
						relevantService = *localService
						relevantServiceName = "LOCAL"
					} else {
						relevantService = *targetService
						relevantServiceName = "TARGET"
					}

					// Filter ports by protocol for the relevant service
					var relevantPorts []models.IngressPort
					for _, port := range relevantService.IngressPorts {
						if port.Protocol == protocol {
							relevantPorts = append(relevantPorts, port)
						}
					}

					klog.Infof("üîç RELEVANCE_CHECK: %s traffic uses %s service %s with %d %s ports",
						rule.Traffic, relevantServiceName, relevantService.Key(), len(relevantPorts), protocol)

					// Skip if the relevant service has no ports for this protocol
					if len(relevantPorts) == 0 {
						klog.Infof("‚ö†Ô∏è AGGREGATION: Skipping AG group - %s service %s has no %s ports",
							relevantServiceName, relevantService.Key(), protocol)
						continue
					}

					// ‚úÖ CRITICAL: Find ALL contributing RuleS2S for this AG pair!
					contributingRules, err := s.findContributingRuleS2S(ctx, reader, rule, *localService, *targetService)
					if err != nil {
						klog.Errorf("üö® AGGREGATION: Failed to find contributing rules: %v", err)
						continue
					}

					// ‚úÖ CRITICAL: Aggregate ports from ALL contributing rules for this protocol!
					aggregatedPorts := s.aggregatePortsWithProtocol(contributingRules, protocol)

					klog.Infof("üéØ FULL_AGGREGATION: AG pair %s ‚Üí %s (%s %s) has %d contributing rules ‚Üí %d aggregated ports: %s",
						localAG.Key(), targetAG.Key(), rule.Traffic, protocol,
						len(contributingRules), len(aggregatedPorts), strings.Join(aggregatedPorts, ","))

					// Create the port group only if we have aggregated ports
					if len(aggregatedPorts) > 0 {
						if portGroups[groupKey] == nil {
							portGroups[groupKey] = make(map[string]bool)
							ruleMetadata[groupKey] = ruleGroupMetadata{
								traffic:   rule.Traffic,
								localAG:   localAG,
								targetAG:  targetAG,
								protocol:  protocol,
								namespace: determineRuleNamespace(rule, localAG, targetAG),
							}
						}

						// Add all aggregated ports to the group
						for _, port := range aggregatedPorts {
							portGroups[groupKey][port] = true
						}

						klog.Infof("‚úÖ FULL_AGGREGATION: Added %d aggregated ports to group %s",
							len(aggregatedPorts), groupKey)
					} else {
						klog.Infof("üóëÔ∏è FULL_AGGREGATION: Skipping group %s with 0 aggregated ports", groupKey)
					}
				}
			}
		}

	}

	// STEP 3: Create IEAgAgRules with AGGREGATED ports (TCP and UDP separately!)
	expectedRules := make(map[string]bool)
	var allNewRules []models.IEAgAgRule

	klog.Infof("üîÑ AGGREGATION: Creating IEAgAgRules from %d port groups", len(portGroups))
	klog.Infof("üìä SUMMARY: Total port groups by protocol:")
	tcpGroupCount := 0
	udpGroupCount := 0
	for groupKey := range portGroups {
		if strings.Contains(groupKey, "|TCP") {
			tcpGroupCount++
		} else if strings.Contains(groupKey, "|UDP") {
			udpGroupCount++
		}
	}
	klog.Infof("  üìä TCP groups: %d, UDP groups: %d", tcpGroupCount, udpGroupCount)

	for groupKey, portsSet := range portGroups {
		metadata := ruleMetadata[groupKey]
		klog.Infof("üî® RULE_CREATE: Processing group %s", groupKey)

		// Collect ports into slice and sort for determinism
		ports := make([]string, 0, len(portsSet))
		for port := range portsSet {
			ports = append(ports, port)
		}
		klog.Infof("  üî® Collected %d ports from set: %v", len(ports), ports)

		// Skip rules with no ports (they will be cleaned up as obsolete)
		if len(ports) == 0 {
			klog.Infof("üóëÔ∏è AGGREGATION: Skipping group %s with 0 ports (will be cleaned up)", groupKey)
			continue
		}

		// Create rule with AGGREGATED ports
		ruleName := generateRuleName(string(metadata.traffic), metadata.localAG.Name, metadata.targetAG.Name, string(metadata.protocol))
		klog.Infof("  üî® Rule name generated: %s", ruleName)

		ieRule := models.IEAgAgRule{
			SelfRef: models.SelfRef{
				ResourceIdentifier: models.NewResourceIdentifier(
					ruleName,
					models.WithNamespace(metadata.namespace),
				),
			},
			Transport:         metadata.protocol,
			Traffic:           metadata.traffic,
			AddressGroupLocal: metadata.localAG,
			AddressGroup:      metadata.targetAG,
			Ports: []models.PortSpec{
				{
					Destination: strings.Join(ports, ","), // ALL ports from ALL RuleS2S combined!
				},
			},
			Action:   models.ActionAccept,
			Logs:     false,
			Trace:    false,
			Priority: 0,
		}

		klog.Infof("  üî® RULE_FIELDS:")
		klog.Infof("    üìç Key: %s", ieRule.Key())
		klog.Infof("    üìç Name: %s", ieRule.SelfRef.Name)
		klog.Infof("    üìç Namespace: %s", ieRule.SelfRef.Namespace)
		klog.Infof("    üìç Transport: %s", ieRule.Transport)
		klog.Infof("    üìç Traffic: %s", ieRule.Traffic)
		klog.Infof("    üìç LocalAG: %s", ieRule.AddressGroupLocal.Key())
		klog.Infof("    üìç TargetAG: %s", ieRule.AddressGroup.Key())
		klog.Infof("    üìç Ports: %s", ieRule.Ports[0].Destination)
		klog.Infof("    üìç Action: %s", ieRule.Action)

		expectedRules[ieRule.Key()] = true
		allNewRules = append(allNewRules, ieRule)

		klog.Infof("‚úÖ AGGREGATION: Created %s IEAgAgRule %s with %d aggregated ports: %s",
			metadata.protocol, ieRule.Key(), len(ports), strings.Join(ports, ","))
	}

	// STEP 4: Sync all new rules at once
	if len(allNewRules) > 0 {
		klog.Infof("üìù AGGREGATION: Syncing %d new IEAgAgRules", len(allNewRules))
		if err = s.syncIEAgAgRules(ctx, writer, allNewRules, syncOp); err != nil {
			return errors.Wrap(err, "failed to sync new IEAgAgRules")
		}
	}

	// STEP 5: Find and delete obsolete rules
	var obsoleteRules []models.IEAgAgRule
	for key, rule := range existingRules {
		if !expectedRules[key] {
			obsoleteRules = append(obsoleteRules, rule)
			klog.Infof("üóëÔ∏è AGGREGATION: Marking rule %s as obsolete", key)
		}
	}

	klog.Infof("üî• AGGREGATION: ================= OBSOLETE DELETION ANALYSIS =================")
	klog.Infof("üî• AGGREGATION: Total existing rules: %d", len(existingRules))
	klog.Infof("üî• AGGREGATION: Total expected rules: %d", len(expectedRules))
	klog.Infof("üî• AGGREGATION: Calculating obsolete rules...")

	if len(obsoleteRules) > 0 {
		klog.Infof("üóëÔ∏è AGGREGATION: Deleting %d obsolete IEAgAgRules", len(obsoleteRules))

		// üìã STEP 1: Log all obsolete rules that will be deleted
		for i, rule := range obsoleteRules {
			klog.Infof("  üóëÔ∏è OBSOLETE[%d]: %s (%s/%s %s‚Üí%s ports=%s)",
				i, rule.Key(), rule.Transport, rule.Traffic,
				rule.AddressGroupLocal.Key(), rule.AddressGroup.Key(),
				rule.Ports[0].Destination)
		}

		// üöÄ STEP 2: CRITICAL - Sync DELETE operation with sgroups FIRST!
		klog.Infof("üîÑ AGGREGATION: Syncing DELETE operation with sgroups for %d obsolete rules", len(obsoleteRules))
		if err = s.syncIEAgAgRules(ctx, writer, obsoleteRules, models.SyncOpDelete); err != nil {
			klog.Errorf("‚ùå AGGREGATION: Failed to sync obsolete rules deletion with sgroups: %v", err)
			return errors.Wrap(err, "failed to sync obsolete IEAgAgRules deletion with sgroups")
		}
		klog.Infof("‚úÖ AGGREGATION: Successfully synced DELETE operation with sgroups")

		// üìã STEP 3: Delete from database AFTER sgroups sync
		var obsoleteRuleIDs []models.ResourceIdentifier
		for _, rule := range obsoleteRules {
			obsoleteRuleIDs = append(obsoleteRuleIDs, rule.ResourceIdentifier)
		}

		klog.Infof("üóÉÔ∏è AGGREGATION: Deleting %d obsolete rules from database", len(obsoleteRuleIDs))
		if err = writer.DeleteIEAgAgRulesByIDs(ctx, obsoleteRuleIDs); err != nil {
			klog.Errorf("‚ùå AGGREGATION: Failed to delete obsolete rules from database: %v", err)
			return errors.Wrap(err, "failed to delete obsolete IEAgAgRules from database")
		}
		klog.Infof("‚úÖ AGGREGATION: Successfully deleted %d obsolete rules from database", len(obsoleteRuleIDs))
	} else {
		klog.Infof("‚úÖ AGGREGATION: No obsolete rules to delete")
	}

	klog.Infof("‚úÖ AGGREGATION: updateIEAgAgRulesForRuleS2SWithReader completed successfully")

	// üìä FINAL SUMMARY
	klog.Infof("üìä AGGREGATION SUMMARY:")
	klog.Infof("    üìä Processed %d RuleS2S", len(rules))
	klog.Infof("    üìä Found %d existing IEAgAgRules", len(existingRules))
	klog.Infof("    üìä Created %d new/updated IEAgAgRules", len(allNewRules))
	klog.Infof("    üìä Deleted %d obsolete IEAgAgRules", len(obsoleteRules))
	klog.Infof("    üìä Net change: %+d rules (%d existing ‚Üí %d expected)",
		len(allNewRules)-len(obsoleteRules), len(existingRules), len(expectedRules))

	return nil
}

// SyncServices syncs services
func (s *NetguardService) SyncServices(ctx context.Context, services []models.Service, scope ports.Scope) error {
	klog.Infof("üî• DEBUG: PUBLIC SyncServices called with %d services", len(services))
	for i, service := range services {
		klog.Infof("üî• DEBUG: PUBLIC Service[%d]: %s, ports=%d", i, service.Key(), len(service.IngressPorts))
		for j, port := range service.IngressPorts {
			klog.Infof("üî• DEBUG: PUBLIC Service[%d].IngressPorts[%d]: %s/%s", i, j, port.Port, port.Protocol)
		}
	}
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator
	validator := validation.NewDependencyValidator(reader)
	serviceValidator := validator.GetServiceValidator()

	// Validate all services
	for _, service := range services {
		// Check if service exists
		existingService, err := reader.GetServiceByID(ctx, service.ResourceIdentifier)
		if err == nil {
			// Service exists - use ValidateForUpdate
			if err := serviceValidator.ValidateForUpdate(ctx, *existingService, service); err != nil {
				return err
			}
		} else {
			// Service is new - use ValidateForCreation
			if err := serviceValidator.ValidateForCreation(ctx, service); err != nil {
				return err
			}
		}
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncServices(ctx, services, scope, ports.WithSyncOp(models.SyncOpFullSync)); err != nil {
		return errors.Wrap(err, "failed to sync services")
	}

	// After successfully syncing services, update related IEAgAgRules
	// OPTIMIZATION: Only update IEAgAgRules for services with changed ports
	var servicesWithChangedPorts []models.ResourceIdentifier
	for _, service := range services {
		// Get existing service for comparison
		existingService, err := reader.GetServiceByID(ctx, service.ResourceIdentifier)
		if err != nil {
			// New service - add to update list
			log.Printf("Service %s is new, will update related IEAgAgRules", service.Key())
			servicesWithChangedPorts = append(servicesWithChangedPorts, service.ResourceIdentifier)
			continue
		}

		// Compare ports between old and new version
		if s.servicePortsChanged(*existingService, service) {
			servicesWithChangedPorts = append(servicesWithChangedPorts, service.ResourceIdentifier)
			log.Printf("Service %s has changed ports, will update related IEAgAgRules", service.Key())
		} else {
			log.Printf("Service %s ports unchanged, skipping IEAgAgRule update", service.Key())
		}
	}

	// Update IEAgAgRules only for services with changed ports
	var allNewIEAgAgRules []models.IEAgAgRule
	if len(servicesWithChangedPorts) > 0 {
		log.Printf("Found %d services with changed ports, updating related IEAgAgRules", len(servicesWithChangedPorts))

		// Find all RuleS2S that reference services with changed ports
		affectedRules, err := s.findRuleS2SForServices(ctx, servicesWithChangedPorts)
		if err != nil {
			writer.Abort()
			return errors.Wrap(err, "failed to find affected RuleS2S")
		}

		log.Printf("Found %d RuleS2S affected by port changes", len(affectedRules))

		if len(affectedRules) > 0 {
			// Get reader that can see changes in current transaction
			txReader, err := s.registry.ReaderFromWriter(ctx, writer)
			if err != nil {
				writer.Abort()
				return errors.Wrap(err, "failed to get transaction reader")
			}
			defer txReader.Close()

			// Update IEAgAgRules with proper port aggregation logic
			if err = s.updateIEAgAgRulesForRuleS2SWithReader(ctx, writer, txReader, affectedRules, models.SyncOpFullSync); err != nil {
				writer.Abort()
				return errors.Wrap(err, "failed to update IEAgAgRules for affected RuleS2S")
			}

			// Get all IEAgAgRules from DB for conditions processing (after aggregation)
			txReader2, err := s.registry.ReaderFromWriter(ctx, writer)
			if err != nil {
				writer.Abort()
				return errors.Wrap(err, "failed to get transaction reader for conditions")
			}
			defer txReader2.Close()

			err = txReader2.ListIEAgAgRules(ctx, func(ieRule models.IEAgAgRule) error {
				allNewIEAgAgRules = append(allNewIEAgAgRules, ieRule)
				return nil
			}, nil)
			if err != nil {
				writer.Abort()
				return errors.Wrap(err, "failed to list all IEAgAgRules for conditions processing")
			}
			log.Printf("SyncServices: Found %d IEAgAgRules for conditions processing", len(allNewIEAgAgRules))
		}
	} else {
		log.Printf("No services with changed ports found, skipping IEAgAgRule updates")
	}

	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// –û–±—Ä–∞–±–æ—Ç–∫–∞ conditions –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ commit
	for i := range services {
		s.conditionManager.ProcessServiceConditions(ctx, &services[i])
		if err := s.conditionManager.saveResourceConditions(ctx, &services[i]); err != nil {
			log.Printf("Failed to save service conditions for %s: %v", services[i].Key(), err)
		}
	}

	// Process conditions for IEAGAG rules created during service update
	for i := range allNewIEAgAgRules {
		if err := s.conditionManager.ProcessIEAgAgRuleConditions(ctx, &allNewIEAgAgRules[i]); err != nil {
			log.Printf("Failed to process IEAgAgRule conditions for %s: %v", allNewIEAgAgRules[i].Key(), err)
		}
		if err := s.conditionManager.saveResourceConditions(ctx, &allNewIEAgAgRules[i]); err != nil {
			log.Printf("Failed to save IEAgAgRule conditions for %s: %v", allNewIEAgAgRules[i].Key(), err)
		}
	}
	return nil
}

// syncAddressGroups —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
func (s *NetguardService) syncAddressGroups(ctx context.Context, writer ports.Writer, addressGroups []models.AddressGroup, syncOp models.SyncOp) error {
	// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
	if syncOp != models.SyncOpDelete {
		reader, err := s.registry.Reader(ctx)
		if err != nil {
			return errors.Wrap(err, "failed to get reader")
		}
		defer reader.Close()

		validator := validation.NewDependencyValidator(reader)
		addressGroupValidator := validator.GetAddressGroupValidator()

		for _, addressGroup := range addressGroups {
			existingAddressGroup, err := reader.GetAddressGroupByID(ctx, addressGroup.ResourceIdentifier)
			if err == nil && syncOp != models.SyncOpDelete {
				// –ì—Ä—É–ø–ø–∞ –∞–¥—Ä–µ—Å–æ–≤ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForUpdate
				if err := addressGroupValidator.ValidateForUpdate(ctx, *existingAddressGroup, addressGroup); err != nil {
					return err
				}
			} else if err == ports.ErrNotFound && syncOp != models.SyncOpDelete {
				// –ì—Ä—É–ø–ø–∞ –∞–¥—Ä–µ—Å–æ–≤ –Ω–æ–≤–∞—è - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForCreation
				if err := addressGroupValidator.ValidateForCreation(ctx, addressGroup); err != nil {
					return err
				}
			} else if err != nil && err != ports.ErrNotFound {
				// –ü—Ä–æ–∏–∑–æ—à–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞
				return errors.Wrap(err, "failed to get address group")
			}
		}
	}

	// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ scope
	var scope ports.Scope
	if syncOp == models.SyncOpFullSync {
		// –ü—Ä–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ FullSync –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Å—Ç—É—é –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏,
		// —á—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å –≤—Å–µ –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤, –∞ –∑–∞—Ç–µ–º –¥–æ–±–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ
		scope = ports.EmptyScope{}
	} else if len(addressGroups) > 0 {
		var ids []models.ResourceIdentifier
		for _, addressGroup := range addressGroups {
			ids = append(ids, addressGroup.ResourceIdentifier)
		}
		scope = ports.NewResourceIdentifierScope(ids...)
	} else {
		scope = ports.EmptyScope{}
	}

	// –ï—Å–ª–∏ —ç—Ç–æ —É–¥–∞–ª–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º DeleteAddressGroupsByIDs –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –∫–∞—Å–∫–∞–¥–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è
	if syncOp == models.SyncOpDelete {
		// –°–æ–±–∏—Ä–∞–µ–º ID –≥—Ä—É–ø–ø –∞–¥—Ä–µ—Å–æ–≤
		var ids []models.ResourceIdentifier
		for _, addressGroup := range addressGroups {
			ids = append(ids, addressGroup.ResourceIdentifier)
		}

		// –ò—Å–ø–æ–ª—å–∑—É–µ–º DeleteAddressGroupsByIDs –¥–ª—è –∫–∞—Å–∫–∞–¥–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è –≥—Ä—É–ø–ø –∞–¥—Ä–µ—Å–æ–≤ –∏ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
		return s.DeleteAddressGroupsByIDs(ctx, ids)
	}

	// –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø—Ü–∏–µ–π –¥–ª—è –Ω–µ-—É–¥–∞–ª–µ–Ω–∏—è
	if err := writer.SyncAddressGroups(ctx, addressGroups, scope, ports.WithSyncOp(syncOp)); err != nil {
		log.Printf("‚ùå ERROR: syncAddressGroups - Failed to sync address groups to writer: %v", err)
		return errors.Wrap(err, "failed to sync address groups")
	}

	if err := writer.Commit(); err != nil {
		log.Printf("‚ùå ERROR: syncAddressGroups - Failed to commit transaction: %v", err)
		return errors.Wrap(err, "failed to commit")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å sgroups –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ commit'–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π —Å–æ–∑–¥–∞–Ω–∏—è/–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è)
	if syncOp != models.SyncOpDelete {
		s.syncAddressGroupsWithSGroups(ctx, addressGroups, types.SyncOperationUpsert)
	}

	return nil
}

// findServicesForAddressGroups finds all Services that reference the given address groups
func (s *NetguardService) findServicesForAddressGroups(ctx context.Context, addressGroupIDs []models.ResourceIdentifier) ([]models.Service, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create a map of address group IDs for quick lookup
	addressGroupMap := make(map[string]bool)
	for _, id := range addressGroupIDs {
		addressGroupMap[id.Key()] = true
	}

	// Find all Services that reference these address groups
	var services []models.Service
	err = reader.ListServices(ctx, func(service models.Service) error {
		// Check if the service references any of the address groups
		for _, ag := range service.AddressGroups {
			if addressGroupMap[ag.Key()] {
				services = append(services, service)
				break
			}
		}
		return nil
	}, nil)

	if err != nil {
		return nil, errors.Wrap(err, "failed to list services")
	}

	return services, nil
}

// SyncAddressGroups syncs address groups
func (s *NetguardService) SyncAddressGroups(ctx context.Context, addressGroups []models.AddressGroup, scope ports.Scope) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator
	validator := validation.NewDependencyValidator(reader)
	addressGroupValidator := validator.GetAddressGroupValidator()

	// Validate all address groups
	for _, addressGroup := range addressGroups {
		// Check if address group exists
		existingAddressGroup, err := reader.GetAddressGroupByID(ctx, addressGroup.ResourceIdentifier)
		if err == nil {
			// Address group exists - use ValidateForUpdate
			if err := addressGroupValidator.ValidateForUpdate(ctx, *existingAddressGroup, addressGroup); err != nil {
				return err
			}
		} else if err == ports.ErrNotFound {
			// Address group is new - use ValidateForCreation
			if err := addressGroupValidator.ValidateForCreation(ctx, addressGroup); err != nil {
				return err
			}
		} else {
			// Other error occurred
			return errors.Wrap(err, "failed to get address group")
		}
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncAddressGroups(ctx, addressGroups, scope, ports.WithSyncOp(models.SyncOpFullSync)); err != nil {
		return errors.Wrap(err, "failed to sync address groups")
	}

	// OPTIMIZATION: AddressGroup contains only IP addresses, not ports. IEAgAgRule updates are not needed here.
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å sgroups –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ commit'–∞
	s.syncAddressGroupsWithSGroups(ctx, addressGroups, types.SyncOperationUpsert)

	return nil
}

// syncAddressGroupsWithSGroups —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç AddressGroup —Å sgroups
func (s *NetguardService) syncAddressGroupsWithSGroups(ctx context.Context, addressGroups []models.AddressGroup, operation types.SyncOperation) {
	if s.syncManager == nil {
		return
	}

	for _, addressGroup := range addressGroups {
		if syncErr := s.syncManager.SyncEntity(ctx, &addressGroup, operation); syncErr != nil {
			log.Printf("‚ùå ERROR: syncAddressGroupsWithSGroups - Failed to sync AddressGroup %s with sgroups: %v", addressGroup.GetSyncKey(), syncErr)
			// –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—Å—Ç–∞–ª—å–Ω—ã—Ö AddressGroup - —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–≤—Ç–æ—Ä–µ–Ω–∞ –ø–æ–∑–∂–µ
		}
	}
}

// syncAddressGroupsWithSGroupsForced —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç AddressGroup —Å sgroups –±–µ–∑ debouncing
func (s *NetguardService) syncAddressGroupsWithSGroupsForced(ctx context.Context, addressGroups []models.AddressGroup, operation types.SyncOperation) {
	if s.syncManager == nil {
		return
	}

	for _, addressGroup := range addressGroups {
		if syncErr := s.syncManager.SyncEntityForced(ctx, &addressGroup, operation); syncErr != nil {
			log.Printf("‚ùå ERROR: syncAddressGroupsWithSGroupsForced - Failed to sync AddressGroup %s with sgroups: %v", addressGroup.GetSyncKey(), syncErr)
			// –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—Å—Ç–∞–ª—å–Ω—ã—Ö AddressGroup - —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–≤—Ç–æ—Ä–µ–Ω–∞ –ø–æ–∑–∂–µ
		}
	}
}

// syncNetworksWithSGroups —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç Network —Å sgroups
func (s *NetguardService) syncNetworksWithSGroups(ctx context.Context, networks []models.Network, operation types.SyncOperation) map[string]error {
	syncResults := make(map[string]error)

	if s.syncManager == nil {
		log.Printf("‚ö†Ô∏è  WARNING: syncNetworksWithSGroups - SyncManager is nil, skipping sync for %d Networks", len(networks))
		// –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫–∏ –¥–ª—è –≤—Å–µ—Ö Networks
		for _, network := range networks {
			syncResults[network.GetSyncKey()] = fmt.Errorf("SyncManager is nil")
		}
		return syncResults
	}

	log.Printf("üîß DEBUG: syncNetworksWithSGroups - Starting sync process for %d Networks (operation: %s)", len(networks), operation)

	for _, network := range networks {
		log.Printf("üîß DEBUG: syncNetworksWithSGroups - Attempting to sync Network %s with sgroups", network.GetSyncKey())
		log.Printf("üîß DEBUG: syncNetworksWithSGroups - Network details: Name=%s, Namespace=%s, SyncSubjectType=%s",
			network.Name, network.Namespace, network.GetSyncSubjectType())

		if syncErr := s.syncManager.SyncEntity(ctx, &network, operation); syncErr != nil {
			log.Printf("‚ùå ERROR: syncNetworksWithSGroups - Failed to sync Network %s with sgroups: %v", network.GetSyncKey(), syncErr)
			syncResults[network.GetSyncKey()] = syncErr
		} else {
			log.Printf("‚úÖ DEBUG: syncNetworksWithSGroups - Successfully initiated sync for Network %s", network.GetSyncKey())
			syncResults[network.GetSyncKey()] = nil // –£—Å–ø–µ—à–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è
		}
	}

	log.Printf("‚úÖ DEBUG: syncNetworksWithSGroups - Completed sync process for %d Networks", len(networks))
	return syncResults
}

// syncNetworksWithSGroupsForced —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç Network —Å sgroups –±–µ–∑ debouncing
func (s *NetguardService) syncNetworksWithSGroupsForced(ctx context.Context, networks []models.Network, operation types.SyncOperation) map[string]error {
	syncResults := make(map[string]error)

	if s.syncManager == nil {
		log.Printf("‚ö†Ô∏è  WARNING: syncNetworksWithSGroupsForced - SyncManager is nil, skipping sync for %d Networks", len(networks))
		// –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫–∏ –¥–ª—è –≤—Å–µ—Ö Networks
		for _, network := range networks {
			syncResults[network.GetSyncKey()] = fmt.Errorf("SyncManager is nil")
		}
		return syncResults
	}

	log.Printf("üîß DEBUG: syncNetworksWithSGroupsForced - Starting FORCED sync process for %d Networks (operation: %s)", len(networks), operation)

	for _, network := range networks {
		log.Printf("üîß DEBUG: syncNetworksWithSGroupsForced - Attempting to FORCE sync Network %s with sgroups", network.GetSyncKey())
		log.Printf("üîß DEBUG: syncNetworksWithSGroupsForced - Network details: Name=%s, Namespace=%s, SyncSubjectType=%s",
			network.Name, network.Namespace, network.GetSyncSubjectType())

		if syncErr := s.syncManager.SyncEntityForced(ctx, &network, operation); syncErr != nil {
			log.Printf("‚ùå ERROR: syncNetworksWithSGroupsForced - Failed to sync Network %s with sgroups: %v", network.GetSyncKey(), syncErr)
			syncResults[network.GetSyncKey()] = syncErr
		} else {
			log.Printf("‚úÖ DEBUG: syncNetworksWithSGroupsForced - Successfully initiated FORCED sync for Network %s", network.GetSyncKey())
			syncResults[network.GetSyncKey()] = nil // –£—Å–ø–µ—à–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è
		}
	}

	log.Printf("‚úÖ DEBUG: syncNetworksWithSGroupsForced - Completed FORCED sync process for %d Networks", len(networks))
	return syncResults
}

// updateServiceAddressGroups updates Service.AddressGroups slice according to the operation ("add" or "remove").
// It returns true if the Service has been modified.
func (s *NetguardService) updateServiceAddressGroups(service *models.Service, addressGroupRef models.AddressGroupRef, operation string) bool {
	updated := false

	switch operation {
	case "add":
		found := false
		for _, ag := range service.AddressGroups {
			if ag.Key() == addressGroupRef.Key() {
				found = true
				break
			}
		}
		if !found {
			service.AddressGroups = append(service.AddressGroups, addressGroupRef)
			updated = true
		}
	case "remove":
		for i, ag := range service.AddressGroups {
			if ag.Key() == addressGroupRef.Key() {
				service.AddressGroups = append(service.AddressGroups[:i], service.AddressGroups[i+1:]...)
				updated = true
				break
			}
		}
	}

	return updated
}

// syncAddressGroupBindings —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–∏–≤—è–∑–∫–∏ –≥—Ä—É–ø–ø –∞–¥—Ä–µ—Å–æ–≤ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
func (s *NetguardService) syncAddressGroupBindings(ctx context.Context, writer ports.Writer, bindings []models.AddressGroupBinding, syncOp models.SyncOp) error {
	// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
	if syncOp != models.SyncOpDelete {
		reader, err := s.registry.Reader(ctx)
		if err != nil {
			return errors.Wrap(err, "failed to get reader")
		}
		defer reader.Close()

		validator := validation.NewDependencyValidator(reader)
		bindingValidator := validator.GetAddressGroupBindingValidator()

		for i := range bindings {
			// Use pointer to binding so we can modify it
			binding := &bindings[i]

			existingBinding, err := reader.GetAddressGroupBindingByID(ctx, binding.ResourceIdentifier)
			if err == nil && syncOp != models.SyncOpDelete {
				// –ü—Ä–∏–≤—è–∑–∫–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForUpdate
				if err := bindingValidator.ValidateForUpdate(ctx, *existingBinding, binding); err != nil {
					return err
				}
			} else if err == ports.ErrNotFound && syncOp != models.SyncOpDelete {
				// –ü—Ä–∏–≤—è–∑–∫–∞ –Ω–æ–≤–∞—è - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForCreation
				if err := bindingValidator.ValidateForCreation(ctx, binding); err != nil {
					return err
				}
			} else if err != nil && err != ports.ErrNotFound {
				// –ü—Ä–æ–∏–∑–æ—à–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞
				return errors.Wrap(err, "failed to get address group binding")
			}
		}
	}

	// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ scope
	var scope ports.Scope
	if syncOp == models.SyncOpFullSync {
		// –ü—Ä–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ FullSync –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Å—Ç—É—é –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏,
		// —á—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å –≤—Å–µ –ø—Ä–∏–≤—è–∑–∫–∏ –≥—Ä—É–ø–ø –∞–¥—Ä–µ—Å–æ–≤, –∞ –∑–∞—Ç–µ–º –¥–æ–±–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ
		scope = ports.EmptyScope{}
	} else if len(bindings) > 0 {
		var ids []models.ResourceIdentifier
		for _, binding := range bindings {
			ids = append(ids, binding.ResourceIdentifier)
		}
		scope = ports.NewResourceIdentifierScope(ids...)
	} else {
		scope = ports.EmptyScope{}
	}

	// –ï—Å–ª–∏ —ç—Ç–æ —É–¥–∞–ª–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º DeleteAddressGroupBindingsByIDs –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –∫–∞—Å–∫–∞–¥–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è
	if syncOp == models.SyncOpDelete {
		// –°–æ–±–∏—Ä–∞–µ–º ID –ø—Ä–∏–≤—è–∑–æ–∫ –≥—Ä—É–ø–ø –∞–¥—Ä–µ—Å–æ–≤
		var ids []models.ResourceIdentifier
		for _, binding := range bindings {
			ids = append(ids, binding.ResourceIdentifier)
		}

		// –ò—Å–ø–æ–ª—å–∑—É–µ–º DeleteAddressGroupBindingsByIDs –¥–ª—è –∫–∞—Å–∫–∞–¥–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è –ø—Ä–∏–≤—è–∑–æ–∫ –∏ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
		return s.DeleteAddressGroupBindingsByIDs(ctx, ids)
	}

	// –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø—Ü–∏–µ–π –¥–ª—è –Ω–µ-—É–¥–∞–ª–µ–Ω–∏—è
	if err := writer.SyncAddressGroupBindings(ctx, bindings, scope, ports.WithSyncOp(syncOp)); err != nil {
		return errors.Wrap(err, "failed to sync address group bindings")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º port mappings –¥–ª—è –∫–∞–∂–¥–æ–≥–æ binding, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ —É–¥–∞–ª–µ–Ω–∏–µ
	if syncOp != models.SyncOpDelete {
		for _, binding := range bindings {
			// –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø—Ä–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ port mappings, —á—Ç–æ–±—ã –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –æ—Å–Ω–æ–≤–Ω—É—é –æ–ø–µ—Ä–∞—Ü–∏—é
			_ = s.SyncAddressGroupPortMappingsWithSyncOp(ctx, binding, syncOp)
		}
	}

	if err := writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	for i := range bindings {
		s.conditionManager.ProcessAddressGroupBindingConditions(ctx, &bindings[i])
		if err := s.conditionManager.saveResourceConditions(ctx, &bindings[i]); err != nil {
			log.Printf("Failed to save address group binding conditions for %s: %v", bindings[i].Key(), err)
		}
	}

	return nil
}

// SyncAddressGroupPortMappingsWithWriter –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é port mapping –¥–ª—è binding
// writer - —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –æ—Ç–∫—Ä—ã—Ç—ã–π writer –¥–ª—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
// syncOp - –æ–ø–µ—Ä–∞—Ü–∏—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ (FullSync, Upsert, Delete)
func (s *NetguardService) SyncAddressGroupPortMappingsWithWriter(ctx context.Context, writer ports.Writer, binding models.AddressGroupBinding, syncOp models.SyncOp) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	return s.SyncAddressGroupPortMappingsWithWriterAndReader(ctx, writer, reader, binding, syncOp)
}

// SyncAddressGroupPortMappingsWithWriterAndReader –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é port mapping –¥–ª—è binding
// writer - —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –æ—Ç–∫—Ä—ã—Ç—ã–π writer –¥–ª—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
// reader - —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –æ—Ç–∫—Ä—ã—Ç—ã–π reader, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –≤–∏–¥–µ—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ç–µ–∫—É—â–µ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
// syncOp - –æ–ø–µ—Ä–∞—Ü–∏—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ (FullSync, Upsert, Delete)
func (s *NetguardService) SyncAddressGroupPortMappingsWithWriterAndReader(ctx context.Context, writer ports.Writer, reader ports.Reader, binding models.AddressGroupBinding, syncOp models.SyncOp) error {
	// –ü–æ–ª—É—á–∞–µ–º —Å–µ—Ä–≤–∏—Å –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –µ–≥–æ –ø–æ—Ä—Ç–∞–º
	service, err := reader.GetServiceByID(ctx, binding.ServiceRef.ResourceIdentifier)
	if err == ports.ErrNotFound {
		return errors.New("service not found for port mapping")
	} else if err != nil {
		return errors.Wrapf(err, "failed to get service for port mapping")
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π port mapping –¥–ª—è —ç—Ç–æ–π address group
	portMapping, err := reader.GetAddressGroupPortMappingByID(ctx, binding.AddressGroupRef.ResourceIdentifier)

	var updatedMapping models.AddressGroupPortMapping

	if err == ports.ErrNotFound {
		// Port mapping –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
		updatedMapping = *validation.CreateNewPortMapping(binding.AddressGroupRef.ResourceIdentifier, *service)
	} else if err != nil {
		// –ü—Ä–æ–∏–∑–æ—à–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞
		return errors.Wrap(err, "failed to get address group port mapping")
	} else {
		// Port mapping —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –æ–±–Ω–æ–≤–ª—è–µ–º –µ–≥–æ
		updatedMapping = *validation.UpdatePortMapping(*portMapping, binding.ServiceRef, *service)

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏–µ –ø–æ—Ä—Ç–æ–≤
		if err := validation.CheckPortOverlaps(*service, updatedMapping); err != nil {
			return err
		}
	}

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π writer –≤–º–µ—Å—Ç–æ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ
	if err = writer.SyncAddressGroupPortMappings(
		ctx,
		[]models.AddressGroupPortMapping{updatedMapping},
		ports.NewResourceIdentifierScope(updatedMapping.ResourceIdentifier),
		ports.WithSyncOp(syncOp),
	); err != nil {
		return errors.Wrap(err, "failed to sync address group port mappings")
	}

	return nil
}

// SyncAddressGroupPortMappings –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é port mapping –¥–ª—è binding
// —Å —Å–æ–∑–¥–∞–Ω–∏–µ–º —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏, –∏—Å–ø–æ–ª—å–∑—É—è –æ–ø–µ—Ä–∞—Ü–∏—é Upsert
func (s *NetguardService) SyncAddressGroupPortMappings(ctx context.Context, binding models.AddressGroupBinding) error {
	return s.SyncAddressGroupPortMappingsWithSyncOp(ctx, binding, models.SyncOpUpsert)
}

// SyncAddressGroupPortMappingsWithSyncOp –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é port mapping –¥–ª—è binding
// —Å —Å–æ–∑–¥–∞–Ω–∏–µ–º —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∏ —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
func (s *NetguardService) SyncAddressGroupPortMappingsWithSyncOp(ctx context.Context, binding models.AddressGroupBinding, syncOp models.SyncOp) error {
	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = s.SyncAddressGroupPortMappingsWithWriter(ctx, writer, binding, syncOp); err != nil {
		return err
	}

	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// –ü–æ–ª—É—á–∞–µ–º —Å–æ–∑–¥–∞–Ω–Ω—ã–π/–æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π mapping –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ conditions
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		log.Printf("Failed to get reader for conditions processing: %v", err)
		return nil // –ù–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É, —Ç–∞–∫ –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞
	}
	defer reader.Close()

	// –ü–æ–ª—É—á–∞–µ–º mapping –ø–æ AddressGroup ID
	mapping, err := reader.GetAddressGroupPortMappingByID(ctx, binding.AddressGroupRef.ResourceIdentifier)
	if err != nil {
		log.Printf("Failed to get port mapping for conditions processing: %v", err)
		return nil
	}

	s.conditionManager.ProcessAddressGroupPortMappingConditions(ctx, mapping)
	if err := s.conditionManager.saveResourceConditions(ctx, mapping); err != nil {
		log.Printf("Failed to save address group port mapping conditions for %s: %v", mapping.Key(), err)
	}

	return nil
}

// SyncAddressGroupBindings syncs address group bindings
func (s *NetguardService) SyncAddressGroupBindings(ctx context.Context, bindings []models.AddressGroupBinding, scope ports.Scope) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator
	validator := validation.NewDependencyValidator(reader)
	bindingValidator := validator.GetAddressGroupBindingValidator()

	// Validate all bindings
	for i := range bindings {
		binding := &bindings[i]

		// Check if binding exists
		existingBinding, err := reader.GetAddressGroupBindingByID(ctx, binding.ResourceIdentifier)
		if err == nil {
			// Binding exists - use ValidateForUpdate
			if err := bindingValidator.ValidateForUpdate(ctx, *existingBinding, binding); err != nil {
				return err
			}
		} else {
			// Binding is new - use ValidateForCreation
			if err := bindingValidator.ValidateForCreation(ctx, binding); err != nil {
				return err
			}
		}
	}

	// –°–æ–∑–¥–∞–µ–º –µ–¥–∏–Ω—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	// --- NEW LOGIC: update Service.AddressGroups before syncing bindings ---
	// Obtain reader that can see uncommitted writes in this transaction
	txReader, err := s.registry.ReaderFromWriter(ctx, writer)
	if err != nil {
		return errors.Wrap(err, "failed to get transaction reader")
	}
	defer txReader.Close()

	var servicesToUpdate []models.Service
	serviceUpdates := make(map[string]*models.Service) // key = service.Key()

	for _, binding := range bindings {
		service, serr := txReader.GetServiceByID(ctx, binding.ServiceRef.ResourceIdentifier)
		if serr != nil {
			if serr == ports.ErrNotFound {
				log.Printf("Service %s not found for binding %s, skipping", binding.ServiceRef.Key(), binding.Key())
				continue
			}
			return errors.Wrapf(serr, "failed to get service %s", binding.ServiceRef.Key())
		}

		key := service.Key()
		if existing, ok := serviceUpdates[key]; ok {
			service = existing
		} else {
			serviceCopy := *service
			serviceUpdates[key] = &serviceCopy
			service = &serviceCopy
		}

		if s.updateServiceAddressGroups(service, binding.AddressGroupRef, "add") {
			log.Printf("Added AddressGroup %s to Service %s", binding.AddressGroupRef.Key(), service.Key())
		}
	}

	for _, svc := range serviceUpdates {
		servicesToUpdate = append(servicesToUpdate, *svc)
	}

	if len(servicesToUpdate) > 0 {
		if err = writer.SyncServices(ctx, servicesToUpdate, nil, ports.WithSyncOp(models.SyncOpUpsert)); err != nil {
			return errors.Wrap(err, "failed to update services with address groups")
		}
	}

	// Sync bindings
	if err = writer.SyncAddressGroupBindings(ctx, bindings, scope, ports.WithSyncOp(models.SyncOpFullSync)); err != nil {
		return errors.Wrap(err, "failed to sync address group bindings")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º port mappings –¥–ª—è –∫–∞–∂–¥–æ–≥–æ binding –≤ —Ç–æ–π –∂–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
	for _, binding := range bindings {
		if err := s.SyncAddressGroupPortMappingsWithWriter(ctx, writer, binding, models.SyncOpFullSync); err != nil {
			return errors.Wrapf(err, "failed to sync port mapping for binding %s", binding.Key())
		}
	}

	// –ü–æ–ª—É—á–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å
	var serviceIDs = make(map[string]models.ResourceIdentifier)
	for _, binding := range bindings {
		serviceIDs[binding.ServiceRef.Key()] = binding.ServiceRef.ResourceIdentifier
	}

	// –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ ServiceAlias, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å —Å–µ—Ä–≤–∏—Å–∞–º–∏ –∏–∑ bindings
	var serviceAliasIDs []models.ResourceIdentifier
	err = reader.ListServiceAliases(ctx, func(alias models.ServiceAlias) error {
		for _, serviceID := range serviceIDs {
			if alias.ServiceRef.Key() == serviceID.Key() {
				serviceAliasIDs = append(serviceAliasIDs, alias.ResourceIdentifier)
				break
			}
		}
		return nil
	}, nil)
	if err != nil {
		return errors.Wrap(err, "failed to list service aliases")
	}

	// –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ RuleS2S, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –Ω–∞–π–¥–µ–Ω–Ω—ã–º–∏ ServiceAlias
	var rulesToUpdate []models.RuleS2S
	err = reader.ListRuleS2S(ctx, func(rule models.RuleS2S) error {
		for _, aliasID := range serviceAliasIDs {
			if rule.ServiceLocalRef.Key() == aliasID.Key() || rule.ServiceRef.Key() == aliasID.Key() {
				rulesToUpdate = append(rulesToUpdate, rule)
				break
			}
		}
		return nil
	}, nil)
	if err != nil {
		return errors.Wrap(err, "failed to list rules s2s")
	}

	log.Printf("SyncAddressGroupBindings: Found %d RuleS2S to update for %d bindings", len(rulesToUpdate), len(bindings))
	// –û–±–Ω–æ–≤–ª—è–µ–º IE AG AG –ø—Ä–∞–≤–∏–ª–∞
	if len(rulesToUpdate) > 0 {
		// –ü–æ–ª—É—á–∞–µ–º reader, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –≤–∏–¥–µ—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ç–µ–∫—É—â–µ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
		txReader, err := s.registry.ReaderFromWriter(ctx, writer)
		if err != nil {
			return errors.Wrap(err, "failed to get transaction reader")
		}
		defer txReader.Close()

		if err = s.updateIEAgAgRulesForRuleS2SWithReader(ctx, writer, txReader, rulesToUpdate, models.SyncOpUpsert); err != nil {
			return errors.Wrap(err, "failed to update IE AG AG rules")
		}
	}

	// –§–∏–∫—Å–∏—Ä—É–µ–º –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –æ–¥–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// –û–±—Ä–∞–±–æ—Ç–∫–∞ conditions –¥–ª—è bindings
	for i := range bindings {
		s.conditionManager.ProcessAddressGroupBindingConditions(ctx, &bindings[i])
		if err := s.conditionManager.saveResourceConditions(ctx, &bindings[i]); err != nil {
			log.Printf("Failed to save address group binding conditions for %s: %v", bindings[i].Key(), err)
		}
	}

	// –û–±—Ä–∞–±–æ—Ç–∫–∞ conditions –¥–ª—è —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö port mappings
	// –ü–æ–ª—É—á–∞–µ–º reader –¥–ª—è —á—Ç–µ–Ω–∏—è —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö mappings
	reader2, err := s.registry.Reader(ctx)
	if err != nil {
		log.Printf("Failed to get reader for port mapping conditions processing: %v", err)
		return nil // –ù–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É, —Ç–∞–∫ –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞
	}
	defer reader2.Close()

	// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º conditions –¥–ª—è –∫–∞–∂–¥–æ–≥–æ port mapping, —Å–æ–∑–¥–∞–Ω–Ω–æ–≥–æ –¥–ª—è bindings
	for _, binding := range bindings {
		mapping, err := reader2.GetAddressGroupPortMappingByID(ctx, binding.AddressGroupRef.ResourceIdentifier)
		if err != nil {
			log.Printf("Failed to get port mapping for conditions processing for %s: %v", binding.AddressGroupRef.Key(), err)
			continue
		}

		s.conditionManager.ProcessAddressGroupPortMappingConditions(ctx, mapping)
		if err := s.conditionManager.saveResourceConditions(ctx, mapping); err != nil {
			log.Printf("Failed to save address group port mapping conditions for %s: %v", mapping.Key(), err)
		}
	}

	return nil
}

// syncAddressGroupPortMappings —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –º–∞–ø–ø–∏–Ω–≥–∏ –ø–æ—Ä—Ç–æ–≤ –≥—Ä—É–ø–ø –∞–¥—Ä–µ—Å–æ–≤ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
// –ù–µ –≤—ã–∑—ã–≤–∞–µ—Ç Commit() - —ç—Ç–æ –¥–æ–ª–∂–µ–Ω –¥–µ–ª–∞—Ç—å –≤—ã–∑—ã–≤–∞—é—â–∏–π –º–µ—Ç–æ–¥
func (s *NetguardService) syncAddressGroupPortMappings(ctx context.Context, writer ports.Writer, mappings []models.AddressGroupPortMapping, syncOp models.SyncOp) error {
	// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
	if syncOp != models.SyncOpDelete {
		reader, err := s.registry.Reader(ctx)
		if err != nil {
			return errors.Wrap(err, "failed to get reader")
		}
		defer reader.Close()

		validator := validation.NewDependencyValidator(reader)
		mappingValidator := validator.GetAddressGroupPortMappingValidator()

		for _, mapping := range mappings {
			existingMapping, err := reader.GetAddressGroupPortMappingByID(ctx, mapping.ResourceIdentifier)
			if err == nil && syncOp != models.SyncOpDelete {
				// –ú–∞–ø–ø–∏–Ω–≥ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForUpdate
				if err := mappingValidator.ValidateForUpdate(ctx, *existingMapping, mapping); err != nil {
					return err
				}
			} else if err == ports.ErrNotFound && syncOp != models.SyncOpDelete {
				// –ú–∞–ø–ø–∏–Ω–≥ –Ω–æ–≤—ã–π - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForCreation
				if err := mappingValidator.ValidateForCreation(ctx, mapping); err != nil {
					return err
				}
			} else if err != nil && err != ports.ErrNotFound {
				// –ü—Ä–æ–∏–∑–æ—à–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞
				return errors.Wrap(err, "failed to get address group port mapping")
			}
		}
	}

	// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ scope
	var scope ports.Scope
	if len(mappings) > 0 {
		var ids []models.ResourceIdentifier
		for _, mapping := range mappings {
			ids = append(ids, mapping.ResourceIdentifier)
		}
		scope = ports.NewResourceIdentifierScope(ids...)
	} else {
		scope = ports.EmptyScope{}
	}

	// –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø—Ü–∏–µ–π
	if err := writer.SyncAddressGroupPortMappings(ctx, mappings, scope, ports.WithSyncOp(syncOp)); err != nil {
		return errors.Wrap(err, "failed to sync address group port mappings")
	}

	// –ù–µ –≤—ã–∑—ã–≤–∞–µ–º Commit() - —ç—Ç–æ –¥–æ–ª–∂–µ–Ω –¥–µ–ª–∞—Ç—å –≤—ã–∑—ã–≤–∞—é—â–∏–π –º–µ—Ç–æ–¥

	return nil
}

// SyncMultipleAddressGroupPortMappings syncs multiple address group port mappings
func (s *NetguardService) SyncMultipleAddressGroupPortMappings(ctx context.Context, mappings []models.AddressGroupPortMapping, scope ports.Scope) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator
	validator := validation.NewDependencyValidator(reader)
	mappingValidator := validator.GetAddressGroupPortMappingValidator()

	// Validate all mappings
	for _, mapping := range mappings {
		// Check if mapping exists
		existingMapping, err := reader.GetAddressGroupPortMappingByID(ctx, mapping.ResourceIdentifier)
		if err == nil {
			// Mapping exists - use ValidateForUpdate
			if err := mappingValidator.ValidateForUpdate(ctx, *existingMapping, mapping); err != nil {
				return err
			}
		} else if err == ports.ErrNotFound {
			// Mapping is new - use ValidateForCreation
			if err := mappingValidator.ValidateForCreation(ctx, mapping); err != nil {
				return err
			}
		} else {
			// Other error occurred
			return errors.Wrap(err, "failed to get address group port mapping")
		}
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ syncAddressGroupPortMappings
	if err = s.syncAddressGroupPortMappings(ctx, writer, mappings, models.SyncOpFullSync); err != nil {
		return err
	}

	// –§–∏–∫—Å–∏—Ä—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	for i := range mappings {
		s.conditionManager.ProcessAddressGroupPortMappingConditions(ctx, &mappings[i])
		if err := s.conditionManager.saveResourceConditions(ctx, &mappings[i]); err != nil {
			log.Printf("Failed to save address group port mapping conditions for %s: %v", mappings[i].Key(), err)
		}
	}
	return nil
}

// syncRuleS2S —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–∞–≤–∏–ª–∞ s2s —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
func (s *NetguardService) syncRuleS2S(ctx context.Context, writer ports.Writer, rules []models.RuleS2S, syncOp models.SyncOp) error {
	// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
	if syncOp != models.SyncOpDelete {
		reader, err := s.registry.Reader(ctx)
		if err != nil {
			return errors.Wrap(err, "failed to get reader")
		}
		defer reader.Close()

		validator := validation.NewDependencyValidator(reader)
		ruleValidator := validator.GetRuleS2SValidator()

		for _, rule := range rules {
			existingRule, err := reader.GetRuleS2SByID(ctx, rule.ResourceIdentifier)
			if err == nil && syncOp != models.SyncOpDelete {
				// –ü—Ä–∞–≤–∏–ª–æ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForUpdate
				if err := ruleValidator.ValidateForUpdate(ctx, *existingRule, rule); err != nil {
					return err
				}
			} else if err == ports.ErrNotFound && syncOp != models.SyncOpDelete {
				// –ü—Ä–∞–≤–∏–ª–æ –Ω–æ–≤–æ–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForCreation
				if err := ruleValidator.ValidateForCreation(ctx, rule); err != nil {
					return err
				}
			} else if err != nil && err != ports.ErrNotFound {
				// –ü—Ä–æ–∏–∑–æ—à–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞
				return errors.Wrap(err, "failed to get rule s2s")
			}
		}
	}

	// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ scope
	var scope ports.Scope
	if len(rules) > 0 {
		var ids []models.ResourceIdentifier
		for _, rule := range rules {
			ids = append(ids, rule.ResourceIdentifier)
		}
		scope = ports.NewResourceIdentifierScope(ids...)
	} else {
		scope = ports.EmptyScope{}
	}

	// –ï—Å–ª–∏ —ç—Ç–æ —É–¥–∞–ª–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º DeleteRuleS2SByIDs –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è —Å–≤—è–∑–∞–Ω–Ω—ã—Ö IE AG AG –ø—Ä–∞–≤–∏–ª
	if syncOp == models.SyncOpDelete {
		// –°–æ–±–∏—Ä–∞–µ–º ID –ø—Ä–∞–≤–∏–ª
		var ids []models.ResourceIdentifier
		for _, rule := range rules {
			ids = append(ids, rule.ResourceIdentifier)
		}

		// –ò—Å–ø–æ–ª—å–∑—É–µ–º DeleteRuleS2SByIDs –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –ø—Ä–∞–≤–∏–ª –∏ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö IE AG AG –ø—Ä–∞–≤–∏–ª
		return s.DeleteRuleS2SByIDs(ctx, ids)
	}

	// –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø—Ü–∏–µ–π –¥–ª—è –Ω–µ-—É–¥–∞–ª–µ–Ω–∏—è
	if err := writer.SyncRuleS2S(ctx, rules, scope, ports.WithSyncOp(syncOp)); err != nil {
		return errors.Wrap(err, "failed to sync rule s2s")
	}

	// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è AG AG –ø—Ä–∞–≤–∏–ª
	log.Printf("syncRuleS2S: Starting IEAgAgRule generation for %d RuleS2S", len(rules))

	// –ü–æ–ª—É—á–∞–µ–º reader, –∫–æ—Ç–æ—Ä—ã–π –≤–∏–¥–∏—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ç–µ–∫—É—â–µ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
	txReader, err := s.registry.ReaderFromWriter(ctx, writer)
	if err != nil {
		return errors.Wrap(err, "failed to get transaction reader")
	}
	defer txReader.Close()

	// –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É –æ–∂–∏–¥–∞–µ–º—ã—Ö –ø—Ä–∞–≤–∏–ª –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
	expectedRules := make(map[string]bool)
	var allNewRules []models.IEAgAgRule

	// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º IEAgAgRules –¥–ª—è –∫–∞–∂–¥–æ–≥–æ RuleS2S
	for i := range rules {
		log.Printf("syncRuleS2S: Generating IEAgAgRules for RuleS2S %d/%d: %s",
			i+1, len(rules), rules[i].Key())

		ieAgAgRules, err := s.GenerateIEAgAgRulesFromRuleS2SWithReader(ctx, txReader, rules[i])
		if err != nil {
			log.Printf("syncRuleS2S: ERROR - Failed to generate IEAgAgRules for RuleS2S %s: %v",
				rules[i].Key(), err)
			return errors.Wrapf(err, "failed to generate IEAgAgRules for RuleS2S %s", rules[i].Key())
		}

		log.Printf("syncRuleS2S: Generated %d IEAgAgRules for RuleS2S %s",
			len(ieAgAgRules), rules[i].Key())

		// –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –≤ RuleS2S
		rules[i].IEAgAgRuleRefs = make([]models.ResourceIdentifier, len(ieAgAgRules))

		// –î–æ–±–∞–≤–ª—è–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –≤ –∫–∞—Ä—Ç—É –æ–∂–∏–¥–∞–µ–º—ã—Ö –ø—Ä–∞–≤–∏–ª –∏ —Å–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –Ω–æ–≤—ã–µ –ø—Ä–∞–≤–∏–ª–∞
		for j, ieRule := range ieAgAgRules {
			rules[i].IEAgAgRuleRefs[j] = ieRule.ResourceIdentifier
			expectedRules[ieRule.Key()] = true
			allNewRules = append(allNewRules, ieRule)
			log.Printf("syncRuleS2S: Added IEAgAgRule reference %d/%d: %s -> %s",
				j+1, len(ieAgAgRules), rules[i].Key(), ieRule.Key())
		}

		log.Printf("syncRuleS2S: Updated RuleS2S %s with %d IEAgAgRuleRefs",
			rules[i].Key(), len(rules[i].IEAgAgRuleRefs))
	}

	log.Printf("syncRuleS2S: Generated total %d IEAgAgRules for all RuleS2S", len(allNewRules))

	// –û–±–Ω–æ–≤–ª—è–µ–º RuleS2S —Å –Ω–æ–≤—ã–º–∏ —Å—Å—ã–ª–∫–∞–º–∏ –Ω–∞ IE AG AG –ø—Ä–∞–≤–∏–ª–∞
	log.Printf("syncRuleS2S: Updating RuleS2S with IEAgAgRuleRefs")
	if err := writer.SyncRuleS2S(ctx, rules, scope, ports.WithSyncOp(models.SyncOpUpsert)); err != nil {
		log.Printf("syncRuleS2S: ERROR - Failed to update RuleS2S with references: %v", err)
		return errors.Wrap(err, "failed to update RuleS2S with IEAgAgRule references")
	}
	log.Printf("syncRuleS2S: Successfully updated RuleS2S with IEAgAgRuleRefs")

	// –ü–æ–ª—É—á–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ IE AG AG –ø—Ä–∞–≤–∏–ª–∞ –ø–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–º —Å—Å—ã–ª–∫–∞–º
	existingRules := make(map[string]models.IEAgAgRule)
	log.Printf("syncRuleS2S: Checking existing IEAgAgRules")

	// –î–ª—è –∫–∞–∂–¥–æ–≥–æ RuleS2S –ø–æ–ª—É—á–∞–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –Ω–∏–º IE AG AG –ø—Ä–∞–≤–∏–ª–∞ –ø–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–º —Å—Å—ã–ª–∫–∞–º
	for _, rule := range rules {
		// –ï—Å–ª–∏ —É –ø—Ä–∞–≤–∏–ª–∞ –µ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ IE AG AG –ø—Ä–∞–≤–∏–ª–∞
		for _, ref := range rule.IEAgAgRuleRefs {
			// –ü–æ–ª—É—á–∞–µ–º IE AG AG –ø—Ä–∞–≤–∏–ª–æ –ø–æ —Å—Å—ã–ª–∫–µ
			ieRule, err := txReader.GetIEAgAgRuleByID(ctx, ref)
			if err == nil && ieRule != nil {
				// –ï—Å–ª–∏ –ø—Ä–∞–≤–∏–ª–æ –Ω–∞–π–¥–µ–Ω–æ –∏ –Ω–µ nil, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –≤ –∫–∞—Ä—Ç—É —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø—Ä–∞–≤–∏–ª
				existingRules[ieRule.Key()] = *ieRule
			} else if err != ports.ErrNotFound {
				// –ï—Å–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, –æ—Ç–ª–∏—á–Ω–∞—è –æ—Ç "–Ω–µ –Ω–∞–π–¥–µ–Ω–æ", –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–µ
				log.Printf("syncRuleS2S: ERROR - Failed to get existing IEAgAgRule %s: %v", ref.Key(), err)
				return errors.Wrapf(err, "failed to get IE AG AG rule %s", ref.Key())
			}
			// –ï—Å–ª–∏ –ø—Ä–∞–≤–∏–ª–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∏–ª–∏ nil, –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –µ–≥–æ
		}
	}
	log.Printf("syncRuleS2S: Found %d existing IEAgAgRules", len(existingRules))

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –≤—Å–µ –Ω–æ–≤—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –∑–∞ –æ–¥–∏–Ω —Ä–∞–∑ WITH sgroups synchronization
	if len(allNewRules) > 0 {
		log.Printf("syncRuleS2S: Syncing %d new IEAgAgRules", len(allNewRules))
		if err = s.syncIEAgAgRules(ctx, writer, allNewRules, models.SyncOpUpsert); err != nil {
			log.Printf("syncRuleS2S: ERROR - Failed to sync IEAgAgRules: %v", err)
			return errors.Wrap(err, "failed to sync new IEAgAgRules")
		}
		log.Printf("syncRuleS2S: Successfully synced %d IEAgAgRules", len(allNewRules))
	} else {
		log.Printf("syncRuleS2S: No new IEAgAgRules to sync")
	}

	// FIXED: –ù–∞—Ö–æ–¥–∏–º –∏ —É–¥–∞–ª—è–µ–º —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ –ø—Ä–∞–≤–∏–ª–∞, –Ω–æ –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –∑–∞–º–µ–Ω—ã
	// –ï—Å–ª–∏ –Ω–æ–≤—ã—Ö –ø—Ä–∞–≤–∏–ª –Ω–µ—Ç (len(allNewRules) == 0), –ù–ï —É–¥–∞–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø—Ä–∞–≤–∏–ª–∞!
	var obsoleteRules []models.IEAgAgRule
	if len(allNewRules) > 0 {
		// –£–¥–∞–ª—è–µ–º obsolete –ø—Ä–∞–≤–∏–ª–∞ –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤—ã–µ –ø—Ä–∞–≤–∏–ª–∞
		for key, rule := range existingRules {
			if !expectedRules[key] {
				obsoleteRules = append(obsoleteRules, rule)
				log.Printf("syncRuleS2S: Found obsolete IEAgAgRule: %s", rule.Key())
			}
		}
	} else {
		// –ï–°–õ–ò –ù–ï–¢ –ù–û–í–´–• –ü–†–ê–í–ò–õ, –ù–ï –£–î–ê–õ–Ø–ï–ú –°–£–©–ï–°–¢–í–£–Æ–©–ò–ï!
		log.Printf("syncRuleS2S: No new rules generated, keeping %d existing IEAgAgRules", len(existingRules))
	}

	if len(obsoleteRules) > 0 {
		log.Printf("syncRuleS2S: Deleting %d obsolete IEAgAgRules", len(obsoleteRules))

		// üìã STEP 1: Log all obsolete rules that will be deleted
		for i, rule := range obsoleteRules {
			log.Printf("  üóëÔ∏è OBSOLETE[%d]: %s (%s/%s %s‚Üí%s ports=%s)",
				i, rule.Key(), rule.Transport, rule.Traffic,
				rule.AddressGroupLocal.Key(), rule.AddressGroup.Key(),
				rule.Ports[0].Destination)
		}

		// üöÄ STEP 2: CRITICAL - Sync DELETE operation with sgroups FIRST!
		log.Printf("üîÑ syncRuleS2S: Syncing DELETE operation with sgroups for %d obsolete rules", len(obsoleteRules))
		if err = s.syncIEAgAgRules(ctx, writer, obsoleteRules, models.SyncOpDelete); err != nil {
			log.Printf("‚ùå syncRuleS2S: Failed to sync obsolete rules deletion with sgroups: %v", err)
			return errors.Wrap(err, "failed to sync obsolete IEAgAgRules deletion with sgroups")
		}
		log.Printf("‚úÖ syncRuleS2S: Successfully synced DELETE operation with sgroups")

		// üìã STEP 3: Delete from database AFTER sgroups sync
		var obsoleteRuleIDs []models.ResourceIdentifier
		for _, rule := range obsoleteRules {
			obsoleteRuleIDs = append(obsoleteRuleIDs, rule.ResourceIdentifier)
		}

		log.Printf("üóÉÔ∏è syncRuleS2S: Deleting %d obsolete rules from database", len(obsoleteRuleIDs))
		if err = writer.DeleteIEAgAgRulesByIDs(ctx, obsoleteRuleIDs); err != nil {
			log.Printf("‚ùå syncRuleS2S: Failed to delete obsolete rules from database: %v", err)
			return errors.Wrap(err, "failed to delete obsolete IEAgAgRules from database")
		}
		log.Printf("‚úÖ syncRuleS2S: Successfully deleted %d obsolete rules from database", len(obsoleteRuleIDs))
	} else {
		log.Printf("‚úÖ syncRuleS2S: No obsolete IEAgAgRules to delete")
	}

	if err := writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// Process conditions for newly created IEAGAG rules after successful commit
	for i := range allNewRules {
		if err := s.conditionManager.ProcessIEAgAgRuleConditions(ctx, &allNewRules[i]); err != nil {
			log.Printf("Failed to process IEAgAgRule conditions for %s: %v", allNewRules[i].Key(), err)
		}
		if err := s.conditionManager.saveResourceConditions(ctx, &allNewRules[i]); err != nil {
			log.Printf("Failed to save IEAgAgRule conditions for %s: %v", allNewRules[i].Key(), err)
		}
	}

	return nil
}

// SyncRuleS2S syncs rule s2s
func (s *NetguardService) SyncRuleS2S(ctx context.Context, rules []models.RuleS2S, scope ports.Scope) error {
	log.Printf("SyncRuleS2S: Starting sync of %d RuleS2S", len(rules))

	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator
	validator := validation.NewDependencyValidator(reader)
	ruleValidator := validator.GetRuleS2SValidator()

	// Validate all rules
	log.Printf("SyncRuleS2S: Validating %d rules", len(rules))
	for i, rule := range rules {
		log.Printf("SyncRuleS2S: Validating rule %d/%d: %s", i+1, len(rules), rule.Key())

		// Check if rule exists
		existingRule, err := reader.GetRuleS2SByID(ctx, rule.ResourceIdentifier)
		if err == nil {
			log.Printf("SyncRuleS2S: Rule %s exists, validating for update", rule.Key())
			// Rule exists - use ValidateForUpdate
			if err := ruleValidator.ValidateForUpdate(ctx, *existingRule, rule); err != nil {
				log.Printf("SyncRuleS2S: Validation failed for existing rule %s: %v", rule.Key(), err)
				return err
			}
		} else if err == ports.ErrNotFound {
			log.Printf("SyncRuleS2S: Rule %s is new, validating for creation", rule.Key())
			// Rule is new - use ValidateForCreation
			if err := ruleValidator.ValidateForCreation(ctx, rule); err != nil {
				log.Printf("SyncRuleS2S: Validation failed for new rule %s: %v", rule.Key(), err)
				return err
			}
		} else {
			log.Printf("SyncRuleS2S: Error checking rule %s: %v", rule.Key(), err)
			// Other error occurred
			return errors.Wrap(err, "failed to get rule s2s")
		}
	}
	log.Printf("SyncRuleS2S: All rules validated successfully")

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			log.Printf("SyncRuleS2S: Aborting transaction due to error: %v", err)
			writer.Abort()
		}
	}()

	// –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –º–µ—Ç–æ–¥ syncRuleS2S –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ IEAgAgRule
	log.Printf("SyncRuleS2S: Calling syncRuleS2S with FullSync operation")
	if err = s.syncRuleS2S(ctx, writer, rules, models.SyncOpFullSync); err != nil {
		log.Printf("SyncRuleS2S: syncRuleS2S failed: %v", err)
		return errors.Wrap(err, "failed to sync rule s2s")
	}

	if err = writer.Commit(); err != nil {
		log.Printf("SyncRuleS2S: Failed to commit transaction: %v", err)
		return errors.Wrap(err, "failed to commit")
	}
	log.Printf("SyncRuleS2S: Transaction committed successfully")

	// Process conditions –¥–ª—è –ø—Ä–∞–≤–∏–ª
	log.Printf("SyncRuleS2S: Processing conditions for %d rules", len(rules))
	for i := range rules {
		log.Printf("SyncRuleS2S: Processing conditions for rule %s", rules[i].Key())
		s.conditionManager.ProcessRuleS2SConditions(ctx, &rules[i])
		if err := s.conditionManager.saveResourceConditions(ctx, &rules[i]); err != nil {
			log.Printf("SyncRuleS2S: Failed to save conditions for rule %s: %v", rules[i].Key(), err)
		}
	}

	log.Printf("SyncRuleS2S: Successfully synced %d RuleS2S", len(rules))
	return nil
}

// syncServiceAliases —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –∞–ª–∏–∞—Å—ã —Å–µ—Ä–≤–∏—Å–æ–≤ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
func (s *NetguardService) syncServiceAliases(ctx context.Context, writer ports.Writer, aliases []models.ServiceAlias, syncOp models.SyncOp) error {
	// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
	if syncOp != models.SyncOpDelete {
		reader, err := s.registry.Reader(ctx)
		if err != nil {
			return errors.Wrap(err, "failed to get reader")
		}
		defer reader.Close()

		validator := validation.NewDependencyValidator(reader)
		aliasValidator := validator.GetServiceAliasValidator()

		for i := range aliases {
			// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç —Å–ª–∞–π—Å–∞, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏—Å—å
			alias := &aliases[i]

			existingAlias, err := reader.GetServiceAliasByID(ctx, alias.ResourceIdentifier)
			if err == nil && syncOp != models.SyncOpDelete {
				// –ê–ª–∏–∞—Å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForUpdate
				if err := aliasValidator.ValidateForUpdate(ctx, *existingAlias, *alias); err != nil {
					return err
				}
			} else if err == ports.ErrNotFound && syncOp != models.SyncOpDelete {
				// –ê–ª–∏–∞—Å –Ω–æ–≤—ã–π - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForCreation
				if err := aliasValidator.ValidateForCreation(ctx, alias); err != nil {
					return err
				}
			} else if err != nil && err != ports.ErrNotFound {
				// –ü—Ä–æ–∏–∑–æ—à–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞
				return errors.Wrap(err, "failed to get service alias")
			}
		}
	}

	// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ scope
	var scope ports.Scope
	if len(aliases) > 0 {
		var ids []models.ResourceIdentifier
		for _, alias := range aliases {
			ids = append(ids, alias.ResourceIdentifier)
		}
		scope = ports.NewResourceIdentifierScope(ids...)
	} else {
		scope = ports.EmptyScope{}
	}

	// –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø—Ü–∏–µ–π
	if err := writer.SyncServiceAliases(ctx, aliases, scope, ports.WithSyncOp(syncOp)); err != nil {
		return errors.Wrap(err, "failed to sync service aliases")
	}

	if err := writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	return nil
}

// CreateServiceAlias —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π –∞–ª–∏–∞—Å —Å–µ—Ä–≤–∏—Å–∞
func (s *NetguardService) CreateServiceAlias(ctx context.Context, alias models.ServiceAlias) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	aliasValidator := validator.GetServiceAliasValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –∞–ª–∏–∞—Å –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º
	if err := aliasValidator.ValidateForCreation(ctx, &alias); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncServiceAliases(ctx, []models.ServiceAlias{alias}, ports.NewResourceIdentifierScope(alias.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to create service alias")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	// –û–±—Ä–∞–±–æ—Ç–∫–∞ conditions
	s.conditionManager.ProcessServiceAliasConditions(ctx, &alias)
	if err := s.conditionManager.saveResourceConditions(ctx, &alias); err != nil {
		return errors.Wrap(err, "failed to save service alias conditions")
	}
	return nil
}

// UpdateServiceAlias –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∞–ª–∏–∞—Å —Å–µ—Ä–≤–∏—Å–∞
func (s *NetguardService) UpdateServiceAlias(ctx context.Context, alias models.ServiceAlias) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é –∞–ª–∏–∞—Å–∞
	oldAlias, err := reader.GetServiceAliasByID(ctx, alias.ResourceIdentifier)
	if err != nil {
		return errors.Wrap(err, "failed to get existing service alias")
	}

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	aliasValidator := validator.GetServiceAliasValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –∞–ª–∏–∞—Å –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
	if err := aliasValidator.ValidateForUpdate(ctx, *oldAlias, alias); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncServiceAliases(ctx, []models.ServiceAlias{alias}, ports.NewResourceIdentifierScope(alias.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to update service alias")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	s.conditionManager.ProcessServiceAliasConditions(ctx, &alias)
	if err := s.conditionManager.saveResourceConditions(ctx, &alias); err != nil {
		return errors.Wrap(err, "failed to save service alias conditions")
	}
	return nil
}

// findRuleS2SForServiceAliases finds all RuleS2S that reference the given service aliases
func (s *NetguardService) findRuleS2SForServiceAliases(ctx context.Context, aliasIDs []models.ResourceIdentifier) ([]models.RuleS2S, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create a map of service alias IDs for quick lookup
	aliasMap := make(map[string]bool)
	for _, id := range aliasIDs {
		aliasMap[id.Key()] = true
	}

	// Find all RuleS2S that reference these service aliases
	var rules []models.RuleS2S
	err = reader.ListRuleS2S(ctx, func(rule models.RuleS2S) error {
		// Check if the rule references any of the service aliases
		if aliasMap[rule.ServiceLocalRef.Key()] || aliasMap[rule.ServiceRef.Key()] {
			rules = append(rules, rule)
		}
		return nil
	}, nil)

	if err != nil {
		return nil, errors.Wrap(err, "failed to list rules")
	}

	return rules, nil
}

// SyncServiceAliases syncs service aliases
func (s *NetguardService) SyncServiceAliases(ctx context.Context, aliases []models.ServiceAlias, scope ports.Scope) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator
	validator := validation.NewDependencyValidator(reader)
	aliasValidator := validator.GetServiceAliasValidator()

	// Validate all aliases
	for i := range aliases {
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç —Å–ª–∞–π—Å–∞, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏—Å—å
		alias := &aliases[i]

		// Check if alias exists
		existingAlias, err := reader.GetServiceAliasByID(ctx, alias.ResourceIdentifier)
		if err == nil {
			// Alias exists - use ValidateForUpdate
			if err := aliasValidator.ValidateForUpdate(ctx, *existingAlias, *alias); err != nil {
				return err
			}
		} else if err == ports.ErrNotFound {
			// Alias is new - use ValidateForCreation
			if err := aliasValidator.ValidateForCreation(ctx, alias); err != nil {
				return err
			}
		} else {
			// Other error occurred
			return errors.Wrap(err, "failed to get service alias")
		}
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	// Find RuleS2S that depend on these ServiceAliases BEFORE making changes
	var aliasIDs []models.ResourceIdentifier
	for _, alias := range aliases {
		aliasIDs = append(aliasIDs, alias.ResourceIdentifier)
	}

	affectedRules, err := s.findRuleS2SForServiceAliases(ctx, aliasIDs)
	if err != nil {
		return errors.Wrap(err, "failed to find affected RuleS2S")
	}

	log.Printf("SyncServiceAliases: Found %d RuleS2S affected by %d ServiceAlias changes", len(affectedRules), len(aliases))

	if err = writer.SyncServiceAliases(ctx, aliases, scope, ports.WithSyncOp(models.SyncOpFullSync)); err != nil {
		return errors.Wrap(err, "failed to sync service aliases")
	}

	// Update IEAgAgRules for affected RuleS2S (ServiceAlias changes can affect Service‚ÜíAddressGroups‚ÜíPorts)
	if len(affectedRules) > 0 {
		// Get reader that can see changes in current transaction
		txReader, err := s.registry.ReaderFromWriter(ctx, writer)
		if err != nil {
			return errors.Wrap(err, "failed to get transaction reader")
		}
		defer txReader.Close()

		if err = s.updateIEAgAgRulesForRuleS2SWithReader(ctx, writer, txReader, affectedRules, models.SyncOpFullSync); err != nil {
			return errors.Wrap(err, "failed to update IEAgAgRules for affected RuleS2S")
		}

		log.Printf("SyncServiceAliases: Updated IEAgAgRules for %d affected RuleS2S", len(affectedRules))
	}

	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// Process conditions after successful commit
	for i := range aliases {
		s.conditionManager.ProcessServiceAliasConditions(ctx, &aliases[i])
		if err := s.conditionManager.saveResourceConditions(ctx, &aliases[i]); err != nil {
			log.Printf("Failed to save service alias conditions for %s: %v", aliases[i].Key(), err)
		}
	}
	return nil
}

// CreateAddressGroupBindingPolicy —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –ø–æ–ª–∏—Ç–∏–∫—É –ø—Ä–∏–≤—è–∑–∫–∏ –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤
func (s *NetguardService) CreateAddressGroupBindingPolicy(ctx context.Context, policy models.AddressGroupBindingPolicy) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	policyValidator := validator.GetAddressGroupBindingPolicyValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –ø–æ–ª–∏—Ç–∏–∫—É –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º
	if err := policyValidator.ValidateForCreation(ctx, &policy); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncAddressGroupBindingPolicies(ctx, []models.AddressGroupBindingPolicy{policy}, ports.NewResourceIdentifierScope(policy.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to create address group binding policy")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	// –û–±—Ä–∞–±–æ—Ç–∫–∞ conditions
	s.conditionManager.ProcessAddressGroupBindingPolicyConditions(ctx, &policy)
	if err := s.conditionManager.saveResourceConditions(ctx, &policy); err != nil {
		return errors.Wrap(err, "failed to save address group binding policy conditions")
	}
	return nil
}

// UpdateAddressGroupBindingPolicy –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ø–æ–ª–∏—Ç–∏–∫—É –ø—Ä–∏–≤—è–∑–∫–∏ –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤
func (s *NetguardService) UpdateAddressGroupBindingPolicy(ctx context.Context, policy models.AddressGroupBindingPolicy) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é –ø–æ–ª–∏—Ç–∏–∫–∏
	oldPolicy, err := reader.GetAddressGroupBindingPolicyByID(ctx, policy.ResourceIdentifier)
	if err != nil {
		return errors.Wrap(err, "failed to get existing address group binding policy")
	}

	// –°–æ–∑–¥–∞–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä
	validator := validation.NewDependencyValidator(reader)
	policyValidator := validator.GetAddressGroupBindingPolicyValidator()

	// –í–∞–ª–∏–¥–∏—Ä—É–µ–º –ø–æ–ª–∏—Ç–∏–∫—É –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
	if err := policyValidator.ValidateForUpdate(ctx, *oldPolicy, &policy); err != nil {
		return err
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncAddressGroupBindingPolicies(ctx, []models.AddressGroupBindingPolicy{policy}, ports.NewResourceIdentifierScope(policy.ResourceIdentifier)); err != nil {
		return errors.Wrap(err, "failed to update address group binding policy")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	s.conditionManager.ProcessAddressGroupBindingPolicyConditions(ctx, &policy)
	if err := s.conditionManager.saveResourceConditions(ctx, &policy); err != nil {
		return errors.Wrap(err, "failed to save address group binding policy conditions")
	}
	return nil
}

// GetSyncStatus returns the status of the last synchronization
func (s *NetguardService) GetSyncStatus(ctx context.Context) (*models.SyncStatus, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	return reader.GetSyncStatus(ctx)
}

// GetServiceByID returns a service by ID
func (s *NetguardService) GetServiceByID(ctx context.Context, id models.ResourceIdentifier) (*models.Service, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	service, err := reader.GetServiceByID(ctx, id)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get service")
	}

	return service, nil
}

// GetAddressGroupByID returns an address group by ID
func (s *NetguardService) GetAddressGroupByID(ctx context.Context, id models.ResourceIdentifier) (*models.AddressGroup, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	addressGroup, err := reader.GetAddressGroupByID(ctx, id)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get address group")
	}

	return addressGroup, nil
}

// GetAddressGroupBindingByID returns an address group binding by ID
func (s *NetguardService) GetAddressGroupBindingByID(ctx context.Context, id models.ResourceIdentifier) (*models.AddressGroupBinding, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	binding, err := reader.GetAddressGroupBindingByID(ctx, id)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get address group binding")
	}

	return binding, nil
}

// GetAddressGroupPortMappingByID returns an address group port mapping by ID
func (s *NetguardService) GetAddressGroupPortMappingByID(ctx context.Context, id models.ResourceIdentifier) (*models.AddressGroupPortMapping, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	mapping, err := reader.GetAddressGroupPortMappingByID(ctx, id)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get address group port mapping")
	}

	return mapping, nil
}

// GetRuleS2SByID returns a rule s2s by ID
func (s *NetguardService) GetRuleS2SByID(ctx context.Context, id models.ResourceIdentifier) (*models.RuleS2S, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	rule, err := reader.GetRuleS2SByID(ctx, id)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get rule s2s")
	}

	return rule, nil
}

// GetServiceAliasByID returns a service alias by ID
func (s *NetguardService) GetServiceAliasByID(ctx context.Context, id models.ResourceIdentifier) (*models.ServiceAlias, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	alias, err := reader.GetServiceAliasByID(ctx, id)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get service alias")
	}

	return alias, nil
}

// GetAddressGroupBindingPolicyByID returns an address group binding policy by ID
func (s *NetguardService) GetAddressGroupBindingPolicyByID(ctx context.Context, id models.ResourceIdentifier) (*models.AddressGroupBindingPolicy, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	policy, err := reader.GetAddressGroupBindingPolicyByID(ctx, id)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get address group binding policy")
	}

	return policy, nil
}

// CreateNetwork creates a new Network with business logic
func (s *NetguardService) CreateNetwork(ctx context.Context, network models.Network) error {
	return s.networkService.CreateNetwork(ctx, &network)
}

// UpdateNetwork updates an existing Network with business logic
func (s *NetguardService) UpdateNetwork(ctx context.Context, network models.Network) error {
	return s.networkService.UpdateNetwork(ctx, &network)
}

// DeleteNetwork deletes a Network with cleanup logic
func (s *NetguardService) DeleteNetwork(ctx context.Context, id models.ResourceIdentifier) error {
	return s.networkService.DeleteNetwork(ctx, id)
}

// GetNetworkByID returns a network by ID
func (s *NetguardService) GetNetworkByID(ctx context.Context, id models.ResourceIdentifier) (*models.Network, error) {
	return s.networkService.GetNetwork(ctx, id)
}

// CreateNetworkBinding creates a new NetworkBinding with business logic
func (s *NetguardService) CreateNetworkBinding(ctx context.Context, binding models.NetworkBinding) error {
	return s.networkBindingService.CreateNetworkBinding(ctx, &binding)
}

// UpdateNetworkBinding updates an existing NetworkBinding with business logic
func (s *NetguardService) UpdateNetworkBinding(ctx context.Context, binding models.NetworkBinding) error {
	return s.networkBindingService.UpdateNetworkBinding(ctx, &binding)
}

// DeleteNetworkBinding deletes a NetworkBinding with cleanup logic
func (s *NetguardService) DeleteNetworkBinding(ctx context.Context, id models.ResourceIdentifier) error {
	return s.networkBindingService.DeleteNetworkBinding(ctx, id)
}

// GetNetworkBindingByID returns a network binding by ID
func (s *NetguardService) GetNetworkBindingByID(ctx context.Context, id models.ResourceIdentifier) (*models.NetworkBinding, error) {
	return s.networkBindingService.GetNetworkBinding(ctx, id)
}

// GetServicesByIDs returns services by IDs
func (s *NetguardService) GetServicesByIDs(ctx context.Context, ids []models.ResourceIdentifier) ([]models.Service, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var services []models.Service
	err = reader.ListServices(ctx, func(service models.Service) error {
		services = append(services, service)
		return nil
	}, ports.NewResourceIdentifierScope(ids...))

	if err != nil {
		return nil, errors.Wrap(err, "failed to list services")
	}

	return services, nil
}

// GetAddressGroupsByIDs returns address groups by IDs
func (s *NetguardService) GetAddressGroupsByIDs(ctx context.Context, ids []models.ResourceIdentifier) ([]models.AddressGroup, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var addressGroups []models.AddressGroup
	err = reader.ListAddressGroups(ctx, func(addressGroup models.AddressGroup) error {
		addressGroups = append(addressGroups, addressGroup)
		return nil
	}, ports.NewResourceIdentifierScope(ids...))

	if err != nil {
		return nil, errors.Wrap(err, "failed to list address groups")
	}

	return addressGroups, nil
}

// GetAddressGroupBindingsByIDs returns address group bindings by IDs
func (s *NetguardService) GetAddressGroupBindingsByIDs(ctx context.Context, ids []models.ResourceIdentifier) ([]models.AddressGroupBinding, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var bindings []models.AddressGroupBinding
	err = reader.ListAddressGroupBindings(ctx, func(binding models.AddressGroupBinding) error {
		bindings = append(bindings, binding)
		return nil
	}, ports.NewResourceIdentifierScope(ids...))

	if err != nil {
		return nil, errors.Wrap(err, "failed to list address group bindings")
	}

	return bindings, nil
}

// GetAddressGroupPortMappingsByIDs returns address group port mappings by IDs
func (s *NetguardService) GetAddressGroupPortMappingsByIDs(ctx context.Context, ids []models.ResourceIdentifier) ([]models.AddressGroupPortMapping, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var mappings []models.AddressGroupPortMapping
	err = reader.ListAddressGroupPortMappings(ctx, func(mapping models.AddressGroupPortMapping) error {
		mappings = append(mappings, mapping)
		return nil
	}, ports.NewResourceIdentifierScope(ids...))

	if err != nil {
		return nil, errors.Wrap(err, "failed to list address group port mappings")
	}

	return mappings, nil
}

// GetRuleS2SByIDs returns rules s2s by IDs
func (s *NetguardService) GetRuleS2SByIDs(ctx context.Context, ids []models.ResourceIdentifier) ([]models.RuleS2S, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var rules []models.RuleS2S
	err = reader.ListRuleS2S(ctx, func(rule models.RuleS2S) error {
		rules = append(rules, rule)
		return nil
	}, ports.NewResourceIdentifierScope(ids...))

	if err != nil {
		return nil, errors.Wrap(err, "failed to list rules s2s")
	}

	return rules, nil
}

// GetServiceAliasesByIDs returns service aliases by IDs
func (s *NetguardService) GetServiceAliasesByIDs(ctx context.Context, ids []models.ResourceIdentifier) ([]models.ServiceAlias, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var aliases []models.ServiceAlias
	err = reader.ListServiceAliases(ctx, func(alias models.ServiceAlias) error {
		aliases = append(aliases, alias)
		return nil
	}, ports.NewResourceIdentifierScope(ids...))

	if err != nil {
		return nil, errors.Wrap(err, "failed to list service aliases")
	}

	return aliases, nil
}

// GetAddressGroupBindingPoliciesByIDs returns address group binding policies by IDs
func (s *NetguardService) GetAddressGroupBindingPoliciesByIDs(ctx context.Context, ids []models.ResourceIdentifier) ([]models.AddressGroupBindingPolicy, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var policies []models.AddressGroupBindingPolicy
	err = reader.ListAddressGroupBindingPolicies(ctx, func(policy models.AddressGroupBindingPolicy) error {
		policies = append(policies, policy)
		return nil
	}, ports.NewResourceIdentifierScope(ids...))

	if err != nil {
		return nil, errors.Wrap(err, "failed to list address group binding policies")
	}

	return policies, nil
}

// GetNetworksByIDs returns networks by IDs
func (s *NetguardService) GetNetworksByIDs(ctx context.Context, ids []models.ResourceIdentifier) ([]models.Network, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var networks []models.Network
	err = reader.ListNetworks(ctx, func(network models.Network) error {
		networks = append(networks, network)
		return nil
	}, ports.NewResourceIdentifierScope(ids...))

	if err != nil {
		return nil, errors.Wrap(err, "failed to list networks")
	}

	return networks, nil
}

// GetNetworkBindingsByIDs returns network bindings by IDs
func (s *NetguardService) GetNetworkBindingsByIDs(ctx context.Context, ids []models.ResourceIdentifier) ([]models.NetworkBinding, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var bindings []models.NetworkBinding
	err = reader.ListNetworkBindings(ctx, func(binding models.NetworkBinding) error {
		bindings = append(bindings, binding)
		return nil
	}, ports.NewResourceIdentifierScope(ids...))

	if err != nil {
		return nil, errors.Wrap(err, "failed to list network bindings")
	}

	return bindings, nil
}

// DeleteServicesByIDs deletes services by IDs with cascade deletion of dependencies
func (s *NetguardService) DeleteServicesByIDs(ctx context.Context, ids []models.ResourceIdentifier) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator for aliases
	validator := validation.NewDependencyValidator(reader)
	aliasValidator := validator.GetServiceAliasValidator()

	// For each service, check its aliases
	for _, id := range ids {
		// Find all aliases of the service
		var serviceAliases []models.ServiceAlias
		err = reader.ListServiceAliases(ctx, func(alias models.ServiceAlias) error {
			if alias.ServiceRef.Key() == id.Key() {
				serviceAliases = append(serviceAliases, alias)
			}
			return nil
		}, nil)

		if err != nil {
			return errors.Wrap(err, "failed to list service aliases")
		}

		// If the service has aliases, check if they have related rules s2s
		for _, alias := range serviceAliases {
			// Check alias dependencies
			if err := aliasValidator.CheckDependencies(ctx, alias.ResourceIdentifier); err != nil {
				// If the alias has dependencies (rules s2s), return an error
				return errors.Wrapf(err, "service %s has alias %s with dependencies", id.Key(), alias.Key())
			}
		}
	}

	// Get all bindings related to the services being deleted
	var bindingsToDelete []models.ResourceIdentifier
	err = reader.ListAddressGroupBindings(ctx, func(binding models.AddressGroupBinding) error {
		for _, id := range ids {
			if binding.ServiceRef.Key() == id.Key() {
				bindingsToDelete = append(bindingsToDelete, binding.ResourceIdentifier)
				break
			}
		}
		return nil
	}, nil)
	if err != nil {
		return errors.Wrap(err, "failed to list address group bindings")
	}

	// Get all service aliases related to the services being deleted
	var serviceAliases []models.ServiceAlias
	err = reader.ListServiceAliases(ctx, func(alias models.ServiceAlias) error {
		for _, id := range ids {
			if alias.ServiceRef.Key() == id.Key() {
				serviceAliases = append(serviceAliases, alias)
				break
			}
		}
		return nil
	}, nil)
	if err != nil {
		return errors.Wrap(err, "failed to list service aliases")
	}

	// Get alias IDs
	var aliasIDs []models.ResourceIdentifier
	for _, alias := range serviceAliases {
		aliasIDs = append(aliasIDs, alias.ResourceIdentifier)
	}

	// Get all RuleS2S rules related to aliases of the services being deleted
	var rulesToDelete []models.ResourceIdentifier
	err = reader.ListRuleS2S(ctx, func(rule models.RuleS2S) error {
		for _, alias := range serviceAliases {
			if rule.ServiceLocalRef.Key() == alias.ResourceIdentifier.Key() ||
				rule.ServiceRef.Key() == alias.ResourceIdentifier.Key() {
				rulesToDelete = append(rulesToDelete, rule.ResourceIdentifier)
				break
			}
		}
		return nil
	}, nil)
	if err != nil {
		return errors.Wrap(err, "failed to list rules s2s")
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	// 1. Delete bindings
	if len(bindingsToDelete) > 0 {
		log.Println("Deleting", len(bindingsToDelete), "bindings for services")
		if err = s.DeleteAddressGroupBindingsByIDs(ctx, bindingsToDelete); err != nil {
			return errors.Wrap(err, "failed to delete address group bindings")
		}
	}

	// 2. Delete RuleS2S rules and related IEAGAG rules
	if len(rulesToDelete) > 0 {
		log.Println("Deleting", len(rulesToDelete), "RuleS2S for services")
		if err = s.DeleteRuleS2SByIDs(ctx, rulesToDelete); err != nil {
			return errors.Wrap(err, "failed to delete rules s2s")
		}
	}

	// 3. Delete service aliases
	if len(aliasIDs) > 0 {
		log.Println("Deleting", len(aliasIDs), "service aliases")
		if err = writer.DeleteServiceAliasesByIDs(ctx, aliasIDs); err != nil {
			return errors.Wrap(err, "failed to delete service aliases")
		}
	}

	// 4. Delete services
	log.Println("Deleting", len(ids), "services")
	if err = writer.DeleteServicesByIDs(ctx, ids); err != nil {
		return errors.Wrap(err, "failed to delete services")
	}

	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	return nil
}

// DeleteAddressGroupsByIDs deletes address groups by IDs with cascade deletion of dependencies
func (s *NetguardService) DeleteAddressGroupsByIDs(ctx context.Context, ids []models.ResourceIdentifier) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Note: We're not checking dependencies here as we're handling them with cascade deletion

	// Get address groups that will be deleted
	var addressGroups []models.AddressGroup
	for _, id := range ids {
		ag, err := reader.GetAddressGroupByID(ctx, id)
		if err != nil {
			continue // Skip if group doesn't exist
		}
		addressGroups = append(addressGroups, *ag)
	}

	// Get all bindings related to the address groups being deleted
	var bindingsToDelete []models.ResourceIdentifier
	err = reader.ListAddressGroupBindings(ctx, func(binding models.AddressGroupBinding) error {
		for _, ag := range addressGroups {
			if binding.AddressGroupRef.Key() == ag.ResourceIdentifier.Key() {
				bindingsToDelete = append(bindingsToDelete, binding.ResourceIdentifier)
				break
			}
		}
		return nil
	}, nil)
	if err != nil {
		return errors.Wrap(err, "failed to list address group bindings")
	}

	// Get all services that reference the address groups being deleted
	var servicesToUpdate []models.Service
	err = reader.ListServices(ctx, func(service models.Service) error {
		serviceUpdated := false
		updatedAGs := make([]models.AddressGroupRef, 0, len(service.AddressGroups))

		// Filter address groups, keeping only those that won't be deleted
		for _, agRef := range service.AddressGroups {
			shouldKeep := true
			for _, id := range ids {
				if agRef.Key() == id.Key() {
					shouldKeep = false
					serviceUpdated = true
					break
				}
			}
			if shouldKeep {
				updatedAGs = append(updatedAGs, agRef)
			}
		}

		if serviceUpdated {
			updatedService := service
			updatedService.AddressGroups = updatedAGs
			servicesToUpdate = append(servicesToUpdate, updatedService)
		}

		return nil
	}, nil)
	if err != nil {
		return errors.Wrap(err, "failed to list services")
	}

	// Get all NetworkBindings that reference the address groups being deleted
	var networkBindingsToDelete []models.ResourceIdentifier
	err = reader.ListNetworkBindings(ctx, func(binding models.NetworkBinding) error {
		for _, id := range ids {
			// ObjectReference —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ Name, —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø–æ –∏–º–µ–Ω–∏
			// NetworkBinding –∏ AddressGroup –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ –æ–¥–Ω–æ–º namespace
			if binding.AddressGroupRef.Name == id.Name && binding.Namespace == id.Namespace {
				networkBindingsToDelete = append(networkBindingsToDelete, binding.ResourceIdentifier)
				log.Printf("üîß DEBUG: DeleteAddressGroupsByIDs - Found NetworkBinding %s referencing AddressGroup %s", binding.Key(), id.Key())
				break
			}
		}
		return nil
	}, nil)
	if err != nil {
		return errors.Wrap(err, "failed to list network bindings")
	}

	// Get all IE AG AG rules that reference the address groups being deleted
	var ieRulesToDelete []models.ResourceIdentifier
	err = reader.ListIEAgAgRules(ctx, func(rule models.IEAgAgRule) error {
		for _, id := range ids {
			if rule.AddressGroupLocal.Key() == id.Key() || rule.AddressGroup.Key() == id.Key() {
				ieRulesToDelete = append(ieRulesToDelete, rule.ResourceIdentifier)
				break
			}
		}
		return nil
	}, nil)
	if err != nil {
		return errors.Wrap(err, "failed to list IE AG AG rules")
	}

	// Start transaction for all operations
	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	// 1. Update Networks to clear binding references BEFORE deleting NetworkBindings
	var networksToUpdate []models.Network
	if len(networkBindingsToDelete) > 0 {
		log.Printf("üîß DEBUG: DeleteAddressGroupsByIDs - Processing %d NetworkBindings for deletion", len(networkBindingsToDelete))

		// –ü–æ–ª—É—á–∞–µ–º NetworkBindings –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã
		for _, bindingID := range networkBindingsToDelete {
			binding, err := reader.GetNetworkBindingByID(ctx, bindingID)
			if err != nil {
				if err == ports.ErrNotFound {
					log.Printf("‚ö†Ô∏è  DEBUG: DeleteAddressGroupsByIDs - NetworkBinding %s not found, skipping", bindingID.Key())
					continue
				}
				return errors.Wrapf(err, "failed to get network binding %s", bindingID.Key())
			}

			// –ù–∞—Ö–æ–¥–∏–º —Å–≤—è–∑–∞–Ω–Ω—É—é Network –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –µ—ë
			networkRef := models.ResourceIdentifier{Name: binding.NetworkRef.Name, Namespace: binding.Namespace}
			network, err := reader.GetNetworkByID(ctx, networkRef)
			if err != nil {
				if err == ports.ErrNotFound {
					log.Printf("‚ö†Ô∏è  DEBUG: DeleteAddressGroupsByIDs - Network %s not found, skipping", networkRef.Key())
					continue
				}
				return errors.Wrapf(err, "failed to get network %s", networkRef.Key())
			}

			log.Printf("üîß DEBUG: DeleteAddressGroupsByIDs - Clearing binding references in Network %s", network.Key())

			// –û—á–∏—â–∞–µ–º binding references
			network.BindingRef = nil
			network.AddressGroupRef = nil
			network.IsBound = false
			network.Meta.TouchOnWrite(fmt.Sprintf("unbinding-ag-deletion-%d", time.Now().UnixNano()))

			networksToUpdate = append(networksToUpdate, *network)
		}

		// –û–±–Ω–æ–≤–ª—è–µ–º Network –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
		if len(networksToUpdate) > 0 {
			log.Printf("üîß DEBUG: DeleteAddressGroupsByIDs - Updating %d Networks to clear binding references", len(networksToUpdate))
			if err = writer.SyncNetworks(ctx, networksToUpdate, nil, ports.WithSyncOp(models.SyncOpUpsert)); err != nil {
				return errors.Wrap(err, "failed to update networks to clear binding references")
			}
		}

		// –¢–µ–ø–µ—Ä—å —É–¥–∞–ª—è–µ–º NetworkBindings
		log.Printf("üîß DEBUG: DeleteAddressGroupsByIDs - Deleting %d NetworkBindings for address groups", len(networkBindingsToDelete))
		if err = writer.DeleteNetworkBindingsByIDs(ctx, networkBindingsToDelete); err != nil {
			return errors.Wrap(err, "failed to delete network bindings")
		}
	}

	// 1.5. –£–¥–∞–ª—è–µ–º Network –∏–∑ AddressGroups –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º —Å–∞–º–∏—Ö AddressGroups
	var updatedAddressGroups []models.AddressGroup
	if len(networksToUpdate) > 0 {
		log.Printf("üîß DEBUG: DeleteAddressGroupsByIDs - Removing Networks from AddressGroups before deletion")

		for _, addressGroup := range addressGroups {
			// –î–ª—è –∫–∞–∂–¥–æ–π AddressGroup —É–¥–∞–ª—è–µ–º Networks –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã
			originalNetworkCount := len(addressGroup.Networks)
			var updatedNetworks []models.NetworkItem

			for _, networkItem := range addressGroup.Networks {
				// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —ç—Ç–∞ —Å–µ—Ç—å —Å—Ä–µ–¥–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö
				shouldRemove := false
				for _, updatedNetwork := range networksToUpdate {
					networkName := fmt.Sprintf("%s/%s", updatedNetwork.Namespace, updatedNetwork.Name)
					if networkItem.Name == networkName {
						shouldRemove = true
						log.Printf("üîß DEBUG: DeleteAddressGroupsByIDs - Removing Network %s from AddressGroup %s", networkName, addressGroup.Key())
						break
					}
				}

				if !shouldRemove {
					updatedNetworks = append(updatedNetworks, networkItem)
				}
			}

			if len(updatedNetworks) != originalNetworkCount {
				addressGroup.Networks = updatedNetworks
				addressGroup.Meta.TouchOnWrite(fmt.Sprintf("network-removal-%d", time.Now().UnixNano()))
				updatedAddressGroups = append(updatedAddressGroups, addressGroup)
				log.Printf("‚úÖ DEBUG: DeleteAddressGroupsByIDs - Removed %d Networks from AddressGroup %s", originalNetworkCount-len(updatedNetworks), addressGroup.Key())
			}
		}

		// –û–±–Ω–æ–≤–ª—è–µ–º AddressGroups –µ—Å–ª–∏ –±—ã–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è
		if len(updatedAddressGroups) > 0 {
			log.Printf("üîß DEBUG: DeleteAddressGroupsByIDs - Updating %d AddressGroups to remove Networks", len(updatedAddressGroups))
			if err = writer.SyncAddressGroups(ctx, updatedAddressGroups, nil, ports.WithSyncOp(models.SyncOpUpsert)); err != nil {
				return errors.Wrap(err, "failed to update address groups to remove networks")
			}
		}
	}

	// 2. Delete AddressGroupBindings
	if len(bindingsToDelete) > 0 {
		log.Println("Deleting", len(bindingsToDelete), "bindings for address groups")
		if err = writer.DeleteAddressGroupBindingsByIDs(ctx, bindingsToDelete); err != nil {
			return errors.Wrap(err, "failed to delete address group bindings")
		}
	}

	// 3. Update services, removing references to deleted address groups
	if len(servicesToUpdate) > 0 {
		log.Println("Updating", len(servicesToUpdate), "services to remove references to deleted address groups")
		if err = writer.SyncServices(ctx, servicesToUpdate, nil, ports.WithSyncOp(models.SyncOpUpsert)); err != nil {
			return errors.Wrap(err, "failed to update services")
		}
	}

	// 4. Delete IE AG AG rules related to the address groups being deleted
	if len(ieRulesToDelete) > 0 {
		log.Println("Deleting", len(ieRulesToDelete), "IE AG AG rules for address groups")
		if err = writer.DeleteIEAgAgRulesByIDs(ctx, ieRulesToDelete); err != nil {
			return errors.Wrap(err, "failed to delete IE AG AG rules")
		}
	}

	// 5. Delete address groups
	log.Println("Deleting", len(ids), "address groups")
	if err = writer.DeleteAddressGroupsByIDs(ctx, ids); err != nil {
		return errors.Wrap(err, "failed to delete address groups")
	}

	// Commit transaction
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö AddressGroups —Å sgroups (–ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º)
	if len(updatedAddressGroups) > 0 {
		log.Printf("üîß DEBUG: DeleteAddressGroupsByIDs - Starting sgroups synchronization for %d updated AddressGroups", len(updatedAddressGroups))
		s.syncAddressGroupsWithSGroups(ctx, updatedAddressGroups, types.SyncOperationUpsert)
		log.Printf("‚úÖ DEBUG: DeleteAddressGroupsByIDs - Completed updated AddressGroups sgroups synchronization")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å sgroups –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –ë–î
	if len(addressGroups) > 0 {
		log.Printf("üîß DEBUG: DeleteAddressGroupsByIDs - Starting sgroups synchronization for %d deleted AddressGroups", len(addressGroups))
		s.syncAddressGroupsWithSGroups(ctx, addressGroups, types.SyncOperationDelete)
		log.Printf("‚úÖ DEBUG: DeleteAddressGroupsByIDs - Completed AddressGroups sgroups synchronization")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö Network —Å sgroups
	if len(networksToUpdate) > 0 {
		log.Printf("üîß DEBUG: DeleteAddressGroupsByIDs - Starting sgroups synchronization for %d updated Networks", len(networksToUpdate))
		networkSyncResults := s.syncNetworksWithSGroups(ctx, networksToUpdate, types.SyncOperationUpsert)
		log.Printf("‚úÖ DEBUG: DeleteAddressGroupsByIDs - Completed Networks sgroups synchronization")

		// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —É—Å–ª–æ–≤–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö Network —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
		for i := range networksToUpdate {
			network := &networksToUpdate[i]
			syncResult := networkSyncResults[network.GetSyncKey()]
			s.conditionManager.ProcessNetworkConditions(ctx, network, syncResult)
			if err := s.conditionManager.saveResourceConditions(ctx, network); err != nil {
				log.Printf("Failed to save network conditions for %s: %v", network.Key(), err)
			}
		}
	}

	return nil
}

// DeleteAddressGroupBindingsByIDs deletes address group bindings by IDs with cascade deletion of dependencies
func (s *NetguardService) DeleteAddressGroupBindingsByIDs(ctx context.Context, ids []models.ResourceIdentifier) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Get bindings that will be deleted
	var bindings []models.AddressGroupBinding
	for _, id := range ids {
		binding, err := reader.GetAddressGroupBindingByID(ctx, id)
		if err != nil || binding == nil {
			continue // Skip if binding doesn't exist
		}
		bindings = append(bindings, *binding)
	}

	// Get services that need to be updated
	var serviceIDs = make(map[string]models.ResourceIdentifier)
	for _, binding := range bindings {
		serviceIDs[binding.ServiceRef.Key()] = binding.ServiceRef.ResourceIdentifier
	}

	// Get all RuleS2S related to services from bindings
	var serviceAliasIDs []models.ResourceIdentifier
	err = reader.ListServiceAliases(ctx, func(alias models.ServiceAlias) error {
		for _, serviceID := range serviceIDs {
			if alias.ServiceRef.Key() == serviceID.Key() {
				serviceAliasIDs = append(serviceAliasIDs, alias.ResourceIdentifier)
				break
			}
		}
		return nil
	}, nil)
	if err != nil {
		return errors.Wrap(err, "failed to list service aliases")
	}

	var rulesToUpdate []models.RuleS2S
	err = reader.ListRuleS2S(ctx, func(rule models.RuleS2S) error {
		for _, aliasID := range serviceAliasIDs {
			if rule.ServiceLocalRef.Key() == aliasID.Key() || rule.ServiceRef.Key() == aliasID.Key() {
				rulesToUpdate = append(rulesToUpdate, rule)
				break
			}
		}
		return nil
	}, nil)
	if err != nil {
		return errors.Wrap(err, "failed to list rules s2s")
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	// --- NEW LOGIC: update Service.AddressGroups before deleting bindings ---
	// Obtain transactional reader
	txReader, err := s.registry.ReaderFromWriter(ctx, writer)
	if err != nil {
		return errors.Wrap(err, "failed to get transaction reader")
	}
	defer txReader.Close()

	var servicesToUpdate []models.Service
	serviceUpdates := make(map[string]*models.Service)

	for _, binding := range bindings {
		service, serr := txReader.GetServiceByID(ctx, binding.ServiceRef.ResourceIdentifier)
		if serr != nil {
			if serr == ports.ErrNotFound {
				continue
			}
			return errors.Wrapf(serr, "failed to get service %s", binding.ServiceRef.Key())
		}
		key := service.Key()
		if existing, ok := serviceUpdates[key]; ok {
			service = existing
		} else {
			serviceCopy := *service
			serviceUpdates[key] = &serviceCopy
			service = &serviceCopy
		}

		if s.updateServiceAddressGroups(service, binding.AddressGroupRef, "remove") {
			log.Printf("Removed AddressGroup %s from Service %s", binding.AddressGroupRef.Key(), service.Key())
		}
	}

	for _, svc := range serviceUpdates {
		servicesToUpdate = append(servicesToUpdate, *svc)
	}

	if len(servicesToUpdate) > 0 {
		if err = writer.SyncServices(ctx, servicesToUpdate, nil, ports.WithSyncOp(models.SyncOpUpsert)); err != nil {
			return errors.Wrap(err, "failed to update services after binding deletion")
		}
	}

	// Delete bindings
	if err = writer.DeleteAddressGroupBindingsByIDs(ctx, ids); err != nil {
		return errors.Wrap(err, "failed to delete address group bindings")
	}

	// Update port mappings for each deleted binding
	for _, binding := range bindings {
		// Check if there are other bindings for the same address group
		hasOtherBindings := false
		err = reader.ListAddressGroupBindings(ctx, func(b models.AddressGroupBinding) error {
			if b.AddressGroupRef.Key() == binding.AddressGroupRef.Key() && b.Key() != binding.Key() {
				hasOtherBindings = true
			}
			return nil
		}, nil)

		if err != nil {
			return errors.Wrap(err, "failed to check for other bindings")
		}

		// If there are no other bindings, delete port mapping
		if !hasOtherBindings {
			if err = writer.DeleteAddressGroupPortMappingsByIDs(ctx, []models.ResourceIdentifier{binding.AddressGroupRef.ResourceIdentifier}); err != nil {
				return errors.Wrap(err, "failed to delete address group port mappings")
			}
		} else {
			// Otherwise update port mapping, removing the service
			portMapping, err := reader.GetAddressGroupPortMappingByID(ctx, binding.AddressGroupRef.ResourceIdentifier)
			if err != nil {
				continue // Skip if port mapping doesn't exist
			}

			// Remove service from port mapping
			delete(portMapping.AccessPorts, binding.ServiceRef)

			// Update port mapping
			if err = writer.SyncAddressGroupPortMappings(
				ctx,
				[]models.AddressGroupPortMapping{*portMapping},
				ports.NewResourceIdentifierScope(portMapping.ResourceIdentifier),
				ports.WithSyncOp(models.SyncOpUpsert),
			); err != nil {
				return errors.Wrap(err, "failed to update address group port mappings")
			}
		}
	}

	// Update RuleS2S and related IEAGAG rules
	if len(rulesToUpdate) > 0 {
		// Get reader that can see changes in the current transaction
		txReader, err := s.registry.ReaderFromWriter(ctx, writer)
		if err != nil {
			return errors.Wrap(err, "failed to get transaction reader")
		}
		defer txReader.Close()

		if err = s.updateIEAgAgRulesForRuleS2SWithReader(ctx, writer, txReader, rulesToUpdate, models.SyncOpUpsert); err != nil {
			return errors.Wrap(err, "failed to update IE AG AG rules")
		}
	}

	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	return nil
}

// DeleteAddressGroupPortMappingsByIDs deletes address group port mappings by IDs
func (s *NetguardService) DeleteAddressGroupPortMappingsByIDs(ctx context.Context, ids []models.ResourceIdentifier) error {
	// Note: Address group port mappings don't have dependencies, so we don't need to check for them
	// However, we could add validation to ensure the mappings exist before deleting them

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.DeleteAddressGroupPortMappingsByIDs(ctx, ids); err != nil {
		return errors.Wrap(err, "failed to delete address group port mappings")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	return nil
}

// DeleteRuleS2SByIDs deletes rules s2s by IDs
func (s *NetguardService) DeleteRuleS2SByIDs(ctx context.Context, ids []models.ResourceIdentifier) error {
	log.Printf("DeleteRuleS2SByIDs: Starting deletion of %d RuleS2S", len(ids))

	// Get a reader to fetch RuleS2S objects
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Use map to deduplicate IEAgAgRule IDs
	ieAgAgRulesToDelete := make(map[string]models.ResourceIdentifier)

	// For each RuleS2S, collect all related IEAgAgRule IDs
	for _, id := range ids {
		log.Printf("DeleteRuleS2SByIDs: Processing RuleS2S %s", id.Key())

		ruleS2S, err := reader.GetRuleS2SByID(ctx, id)
		if err != nil || ruleS2S == nil {
			log.Printf("DeleteRuleS2SByIDs: RuleS2S %s not found, skipping: %v", id.Key(), err)
			continue
		}

		log.Printf("DeleteRuleS2SByIDs: Found RuleS2S %s with %d saved IEAgAgRuleRefs",
			ruleS2S.Key(), len(ruleS2S.IEAgAgRuleRefs))

		// 1. –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ —Å—Å—ã–ª–∫–∏
		if len(ruleS2S.IEAgAgRuleRefs) > 0 {
			log.Printf("DeleteRuleS2SByIDs: Adding %d saved IEAgAgRule references", len(ruleS2S.IEAgAgRuleRefs))
			for _, ref := range ruleS2S.IEAgAgRuleRefs {
				ieAgAgRulesToDelete[ref.Key()] = ref
				log.Printf("DeleteRuleS2SByIDs: Added saved reference: %s", ref.Key())
			}
		} else {
			log.Printf("DeleteRuleS2SByIDs: WARNING - RuleS2S %s has no saved IEAgAgRule references", ruleS2S.Key())
		}

		// 2. –í–°–ï–ì–î–ê –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ–∂–∏–¥–∞–µ–º—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∏—Ö —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ
		log.Printf("DeleteRuleS2SByIDs: Generating expected IEAgAgRules for RuleS2S %s", ruleS2S.Key())
		expectedRules, err := s.GenerateIEAgAgRulesFromRuleS2SWithReader(ctx, reader, *ruleS2S)
		if err != nil {
			log.Printf("DeleteRuleS2SByIDs: ERROR - Failed to generate expected rules for %s: %v", ruleS2S.Key(), err)
			continue
		}

		log.Printf("DeleteRuleS2SByIDs: Generated %d expected IEAgAgRules", len(expectedRules))

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ –æ–∂–∏–¥–∞–µ–º–æ–≥–æ –ø—Ä–∞–≤–∏–ª–∞
		foundCount := 0
		for _, expectedRule := range expectedRules {
			existingRule, err := reader.GetIEAgAgRuleByID(ctx, expectedRule.ResourceIdentifier)
			if err == nil && existingRule != nil {
				ieAgAgRulesToDelete[existingRule.Key()] = existingRule.ResourceIdentifier
				foundCount++
				log.Printf("DeleteRuleS2SByIDs: Found existing IEAgAgRule %s", existingRule.Key())
			} else {
				log.Printf("DeleteRuleS2SByIDs: Expected IEAgAgRule %s not found", expectedRule.Key())
			}
		}

		log.Printf("DeleteRuleS2SByIDs: Found %d out of %d expected IEAgAgRules for RuleS2S %s",
			foundCount, len(expectedRules), ruleS2S.Key())
	}

	// Convert map to slice for deletion
	var ieAgAgRuleIDs []models.ResourceIdentifier
	for _, id := range ieAgAgRulesToDelete {
		ieAgAgRuleIDs = append(ieAgAgRuleIDs, id)
	}

	log.Printf("DeleteRuleS2SByIDs: Total unique IEAgAgRules to delete: %d", len(ieAgAgRuleIDs))

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			log.Printf("DeleteRuleS2SByIDs: Aborting transaction due to error: %v", err)
			writer.Abort()
		}
	}()

	// First delete the associated IEAgAgRules
	if len(ieAgAgRuleIDs) > 0 {
		log.Printf("DeleteRuleS2SByIDs: Deleting %d IEAgAgRules", len(ieAgAgRuleIDs))
		for i, ruleID := range ieAgAgRuleIDs {
			log.Printf("DeleteRuleS2SByIDs: Deleting IEAgAgRule %d/%d: %s", i+1, len(ieAgAgRuleIDs), ruleID.Key())
		}

		if err = writer.DeleteIEAgAgRulesByIDs(ctx, ieAgAgRuleIDs); err != nil {
			log.Printf("DeleteRuleS2SByIDs: ERROR - Failed to delete IEAgAgRules: %v", err)
			return errors.Wrap(err, "failed to delete associated IEAgAgRules")
		}
		log.Printf("DeleteRuleS2SByIDs: Successfully deleted %d IEAgAgRules", len(ieAgAgRuleIDs))
	} else {
		log.Printf("DeleteRuleS2SByIDs: No IEAgAgRules found to delete")
	}

	// Then delete the RuleS2S objects
	log.Printf("DeleteRuleS2SByIDs: Deleting %d RuleS2S objects", len(ids))
	for i, id := range ids {
		log.Printf("DeleteRuleS2SByIDs: Deleting RuleS2S %d/%d: %s", i+1, len(ids), id.Key())
	}

	if err = writer.DeleteRuleS2SByIDs(ctx, ids); err != nil {
		log.Printf("DeleteRuleS2SByIDs: ERROR - Failed to delete RuleS2S objects: %v", err)
		return errors.Wrap(err, "failed to delete rules s2s")
	}

	if err = writer.Commit(); err != nil {
		log.Printf("DeleteRuleS2SByIDs: ERROR - Failed to commit transaction: %v", err)
		return errors.Wrap(err, "failed to commit")
	}

	log.Printf("DeleteRuleS2SByIDs: Successfully deleted %d RuleS2S and %d associated IEAgAgRules",
		len(ids), len(ieAgAgRuleIDs))
	return nil
}

// DeleteServiceAliasesByIDs deletes service aliases by IDs
func (s *NetguardService) DeleteServiceAliasesByIDs(ctx context.Context, ids []models.ResourceIdentifier) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator
	validator := validation.NewDependencyValidator(reader)
	aliasValidator := validator.GetServiceAliasValidator()

	// Check dependencies for each service alias
	for _, id := range ids {
		if err := aliasValidator.CheckDependencies(ctx, id); err != nil {
			return err
		}
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	// Find RuleS2S that depend on these ServiceAliases BEFORE deletion
	affectedRules, err := s.findRuleS2SForServiceAliases(ctx, ids)
	if err != nil {
		return errors.Wrap(err, "failed to find affected RuleS2S")
	}

	log.Printf("DeleteServiceAliasesByIDs: Found %d RuleS2S affected by deletion of %d ServiceAliases", len(affectedRules), len(ids))

	if err = writer.DeleteServiceAliasesByIDs(ctx, ids); err != nil {
		return errors.Wrap(err, "failed to delete service aliases")
	}

	// Update IEAgAgRules for affected RuleS2S (deletion of ServiceAlias makes RuleS2S inactive)
	if len(affectedRules) > 0 {
		// Get reader that can see changes in current transaction
		txReader, err := s.registry.ReaderFromWriter(ctx, writer)
		if err != nil {
			return errors.Wrap(err, "failed to get transaction reader")
		}
		defer txReader.Close()

		// ServiceAlias deletion makes RuleS2S inactive ‚Üí delete all related IEAgAgRules
		if err = s.updateIEAgAgRulesForRuleS2SWithReader(ctx, writer, txReader, affectedRules, models.SyncOpFullSync); err != nil {
			return errors.Wrap(err, "failed to update IEAgAgRules for affected RuleS2S")
		}

		log.Printf("DeleteServiceAliasesByIDs: Updated IEAgAgRules for %d affected RuleS2S", len(affectedRules))
	}

	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	return nil
}

// syncAddressGroupBindingPolicies —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –ø–æ–ª–∏—Ç–∏–∫–∏ –ø—Ä–∏–≤—è–∑–∫–∏ –≥—Ä—É–ø–ø –∞–¥—Ä–µ—Å–æ–≤ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
func (s *NetguardService) syncAddressGroupBindingPolicies(ctx context.Context, writer ports.Writer, policies []models.AddressGroupBindingPolicy, syncOp models.SyncOp) error {
	// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
	if syncOp != models.SyncOpDelete {
		reader, err := s.registry.Reader(ctx)
		if err != nil {
			return errors.Wrap(err, "failed to get reader")
		}
		defer reader.Close()

		validator := validation.NewDependencyValidator(reader)
		policyValidator := validator.GetAddressGroupBindingPolicyValidator()

		for i := range policies {
			// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç —Å–ª–∞–π—Å–∞, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏—Å—å
			policy := &policies[i]

			existingPolicy, err := reader.GetAddressGroupBindingPolicyByID(ctx, policy.ResourceIdentifier)
			if err == nil && syncOp != models.SyncOpDelete {
				// –ü–æ–ª–∏—Ç–∏–∫–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForUpdate
				if err := policyValidator.ValidateForUpdate(ctx, *existingPolicy, policy); err != nil {
					return err
				}
			} else if err == ports.ErrNotFound && syncOp != models.SyncOpDelete {
				// –ü–æ–ª–∏—Ç–∏–∫–∞ –Ω–æ–≤–∞—è - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForCreation
				if err := policyValidator.ValidateForCreation(ctx, policy); err != nil {
					return err
				}
			} else if err != nil && err != ports.ErrNotFound {
				// –ü—Ä–æ–∏–∑–æ—à–ª–∞ –¥—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞
				return errors.Wrap(err, "failed to get address group binding policy")
			}
		}
	}

	// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ scope
	var scope ports.Scope
	if len(policies) > 0 {
		var ids []models.ResourceIdentifier
		for _, policy := range policies {
			ids = append(ids, policy.ResourceIdentifier)
		}
		scope = ports.NewResourceIdentifierScope(ids...)
	} else {
		scope = ports.EmptyScope{}
	}

	// –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø—Ü–∏–µ–π
	if err := writer.SyncAddressGroupBindingPolicies(ctx, policies, scope, ports.WithSyncOp(syncOp)); err != nil {
		return errors.Wrap(err, "failed to sync address group binding policies")
	}

	if err := writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	return nil
}

// SyncAddressGroupBindingPolicies syncs address group binding policies
func (s *NetguardService) SyncAddressGroupBindingPolicies(ctx context.Context, policies []models.AddressGroupBindingPolicy, scope ports.Scope) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator
	validator := validation.NewDependencyValidator(reader)
	policyValidator := validator.GetAddressGroupBindingPolicyValidator()

	// Validate all policies
	for i := range policies {
		// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç —Å–ª–∞–π—Å–∞, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏—Å—å
		policy := &policies[i]

		// Check if policy exists
		existingPolicy, err := reader.GetAddressGroupBindingPolicyByID(ctx, policy.ResourceIdentifier)
		if err == nil {
			// Policy exists - use ValidateForUpdate
			if err := policyValidator.ValidateForUpdate(ctx, *existingPolicy, policy); err != nil {
				return err
			}
		} else if err == ports.ErrNotFound {
			// Policy is new - use ValidateForCreation
			if err := policyValidator.ValidateForCreation(ctx, policy); err != nil {
				return err
			}
		} else {
			// Other error occurred
			return errors.Wrap(err, "failed to get address group binding policy")
		}
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncAddressGroupBindingPolicies(ctx, policies, scope, ports.WithSyncOp(models.SyncOpFullSync)); err != nil {
		return errors.Wrap(err, "failed to sync address group binding policies")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	for i := range policies {
		s.conditionManager.ProcessAddressGroupBindingPolicyConditions(ctx, &policies[i])
		if err := s.conditionManager.saveResourceConditions(ctx, &policies[i]); err != nil {
			log.Printf("Failed to save address group binding policy conditions for %s: %v", policies[i].Key(), err)
		}
	}
	return nil
}

// GetIEAgAgRules returns a list of IEAgAgRules
func (s *NetguardService) GetIEAgAgRules(ctx context.Context, scope ports.Scope) ([]models.IEAgAgRule, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var result []models.IEAgAgRule

	err = reader.ListIEAgAgRules(ctx, func(rule models.IEAgAgRule) error {
		result = append(result, rule)
		return nil
	}, scope)

	if err != nil {
		return nil, errors.Wrap(err, "failed to list IEAgAgRules")
	}

	return result, nil
}

// GetIEAgAgRuleByID returns a IEAgAgRule by ID
func (s *NetguardService) GetIEAgAgRuleByID(ctx context.Context, id models.ResourceIdentifier) (*models.IEAgAgRule, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	return reader.GetIEAgAgRuleByID(ctx, id)
}

// syncIEAgAgRulesWithReader —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–∞–≤–∏–ª–∞ IEAgAgRule —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π, –∏—Å–ø–æ–ª—å–∑—É—è –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π reader
func (s *NetguardService) syncIEAgAgRulesWithReader(ctx context.Context, writer ports.Writer, reader ports.Reader, rules []models.IEAgAgRule, syncOp models.SyncOp) error {
	log.Printf("üöÄ CALLED: syncIEAgAgRulesWithReader function called with %d rules, syncOp=%s", len(rules), syncOp)
	// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
	if syncOp != models.SyncOpDelete {

		validator := validation.NewDependencyValidator(reader)
		ruleValidator := validator.GetIEAgAgRuleValidator()

		for _, rule := range rules {
			existingRule, err := reader.GetIEAgAgRuleByID(ctx, rule.ResourceIdentifier)
			if err == nil && syncOp != models.SyncOpDelete {
				// –ü—Ä–∞–≤–∏–ª–æ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForUpdate
				if err := ruleValidator.ValidateForUpdate(ctx, *existingRule, rule); err != nil {
					return err
				}
			} else if syncOp != models.SyncOpDelete {
				// –ü—Ä–∞–≤–∏–ª–æ –Ω–æ–≤–æ–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º ValidateForCreation
				if err := ruleValidator.ValidateForCreation(ctx, rule); err != nil {
					return err
				}
			}
		}
	}

	// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ scope
	var scope ports.Scope
	if len(rules) > 0 {
		var ids []models.ResourceIdentifier
		for _, rule := range rules {
			ids = append(ids, rule.ResourceIdentifier)
		}
		scope = ports.NewResourceIdentifierScope(ids...)
	} else {
		scope = ports.EmptyScope{}
	}

	// –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø—Ü–∏–µ–π
	if err := writer.SyncIEAgAgRules(ctx, rules, scope, ports.WithSyncOp(syncOp)); err != nil {
		return errors.Wrap(err, "failed to sync IEAgAgRules")
	}

	if err := writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// Sync with sgroups after successful commit
	if s.syncManager == nil {
		log.Printf("‚ö†Ô∏è  WARNING: syncManager is nil, skipping sgroups synchronization for %d IEAgAgRule(s)", len(rules))
	} else if len(rules) == 0 {
		log.Printf("‚ö†Ô∏è  WARNING: No IEAgAgRules to sync with sgroups")
	} else {
		log.Printf("üîß DEBUG: Starting sgroups synchronization for %d IEAgAgRule(s)", len(rules))
		for i := range rules {
			log.Printf("üîß DEBUG: Syncing IEAgAgRule %s with sgroups (Transport: %s, Traffic: %s, Action: %s)",
				rules[i].Key(), rules[i].Transport, rules[i].Traffic, rules[i].Action)

			if syncOp == models.SyncOpDelete {
				if syncErr := s.syncManager.SyncEntity(ctx, &rules[i], types.SyncOperationDelete); syncErr != nil {
					log.Printf("‚ùå Failed to sync IEAgAgRule %s with sgroups (delete): %v", rules[i].Key(), syncErr)
				} else {
					log.Printf("‚úÖ Successfully synced IEAgAgRule %s with sgroups (delete)", rules[i].Key())
				}
			} else {
				if syncErr := s.syncManager.SyncEntity(ctx, &rules[i], types.SyncOperationUpsert); syncErr != nil {
					log.Printf("‚ùå Failed to sync IEAgAgRule %s with sgroups: %v", rules[i].Key(), syncErr)
				} else {
					log.Printf("‚úÖ Successfully synced IEAgAgRule %s with sgroups", rules[i].Key())
				}
			}
		}
		log.Printf("‚úÖ DEBUG: Completed sgroups synchronization for IEAgAgRules")
	}

	// Process conditions after sgroups sync
	for i := range rules {
		s.conditionManager.ProcessIEAgAgRuleConditions(ctx, &rules[i])
		if err := s.conditionManager.saveResourceConditions(ctx, &rules[i]); err != nil {
			log.Printf("Failed to save IEAgAgRule conditions for %s: %v", rules[i].Key(), err)
		}
	}
	return nil
}

// syncIEAgAgRules —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–∞–≤–∏–ª–∞ IEAgAgRule —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π (—Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π reader)
func (s *NetguardService) syncIEAgAgRules(ctx context.Context, writer ports.Writer, rules []models.IEAgAgRule, syncOp models.SyncOp) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	return s.syncIEAgAgRulesWithReader(ctx, writer, reader, rules, syncOp)
}

// syncNetworks —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç —Å–µ—Ç–∏ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
func (s *NetguardService) syncNetworks(ctx context.Context, writer ports.Writer, networks []models.Network, syncOp models.SyncOp) error {
	// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
	if syncOp != models.SyncOpDelete {
		reader, err := s.registry.Reader(ctx)
		if err != nil {
			return errors.Wrap(err, "failed to get reader")
		}
		defer reader.Close()

		// Create validator
		validator := validation.NewDependencyValidator(reader)
		networkValidator := validator.GetNetworkValidator()

		// Validate all networks
		for i := range networks {
			network := &networks[i]

			// Check if network exists
			networkID := models.ResourceIdentifier{Name: network.Name, Namespace: network.Namespace}
			existingNetwork, err := reader.GetNetworkByID(ctx, networkID)
			if err == nil {
				// Network exists - use ValidateForUpdate
				if err := networkValidator.ValidateForUpdate(ctx, *existingNetwork, *network); err != nil {
					return err
				}
			} else if err == ports.ErrNotFound {
				// Network is new - use ValidateForCreation
				if err := networkValidator.ValidateForCreation(ctx, *network); err != nil {
					return err
				}
			} else {
				// Other error occurred
				return errors.Wrap(err, "failed to get network")
			}
		}
	}

	// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ scope
	var scope ports.Scope
	if len(networks) > 0 {
		var ids []models.ResourceIdentifier
		for _, network := range networks {
			ids = append(ids, models.ResourceIdentifier{Name: network.Name, Namespace: network.Namespace})
		}
		scope = ports.NewResourceIdentifierScope(ids...)
	} else {
		scope = ports.EmptyScope{}
	}

	// –ï—Å–ª–∏ —ç—Ç–æ —É–¥–∞–ª–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º DeleteNetworksByIDs –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è
	if syncOp == models.SyncOpDelete {
		// –°–æ–±–∏—Ä–∞–µ–º ID —Å–µ—Ç–µ–π
		var ids []models.ResourceIdentifier
		for _, network := range networks {
			ids = append(ids, models.ResourceIdentifier{Name: network.Name, Namespace: network.Namespace})
		}

		// –ò—Å–ø–æ–ª—å–∑—É–µ–º DeleteNetworksByIDs –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Å–µ—Ç–µ–π
		return s.DeleteNetworksByIDs(ctx, ids)
	}

	// –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø—Ü–∏–µ–π –¥–ª—è –Ω–µ-—É–¥–∞–ª–µ–Ω–∏—è
	if err := writer.SyncNetworks(ctx, networks, scope, ports.WithSyncOp(syncOp)); err != nil {
		return errors.Wrap(err, "failed to sync networks")
	}

	if err := writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å sgroups –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ commit'–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π —Å–æ–∑–¥–∞–Ω–∏—è/–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è)
	var sgroupsSyncResults map[string]error
	if syncOp != models.SyncOpDelete {
		log.Printf("üîß DEBUG: syncNetworks - Starting sgroups synchronization for %d Networks", len(networks))
		sgroupsSyncResults = s.syncNetworksWithSGroups(ctx, networks, types.SyncOperationUpsert)
		log.Printf("‚úÖ DEBUG: syncNetworks - Completed sgroups synchronization")
	} else {
		log.Printf("‚ö†Ô∏è  DEBUG: syncNetworks - Skipping sgroups sync for DELETE operation (handled separately)")
		// –î–ª—è DELETE –æ–ø–µ—Ä–∞—Ü–∏–π —Å—á–∏—Ç–∞–µ–º —á—Ç–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞ (–Ω–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤ sgroups sync)
		sgroupsSyncResults = make(map[string]error)
		for _, network := range networks {
			sgroupsSyncResults[network.GetSyncKey()] = nil
		}
	}

	for i := range networks {
		network := &networks[i]
		syncResult := sgroupsSyncResults[network.GetSyncKey()]
		s.conditionManager.ProcessNetworkConditions(ctx, network, syncResult)
		if err := s.conditionManager.saveResourceConditions(ctx, network); err != nil {
			log.Printf("Failed to save network conditions for %s: %v", network.Key(), err)
		}
	}
	return nil
}

// syncNetworkBindings —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–∏–≤—è–∑–∫–∏ —Å–µ—Ç–µ–π —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
func (s *NetguardService) syncNetworkBindings(ctx context.Context, writer ports.Writer, bindings []models.NetworkBinding, syncOp models.SyncOp) error {
	// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏
	if syncOp != models.SyncOpDelete {
		reader, err := s.registry.Reader(ctx)
		if err != nil {
			return errors.Wrap(err, "failed to get reader")
		}
		defer reader.Close()

		// Create validator
		validator := validation.NewDependencyValidator(reader)
		bindingValidator := validator.GetNetworkBindingValidator()

		// Validate all bindings
		for i := range bindings {
			binding := &bindings[i]

			// Check if binding exists
			bindingID := models.ResourceIdentifier{Name: binding.Name, Namespace: binding.Namespace}
			existingBinding, err := reader.GetNetworkBindingByID(ctx, bindingID)
			if err == nil {
				// Binding exists - use ValidateForUpdate
				if err := bindingValidator.ValidateForUpdate(ctx, *existingBinding, *binding); err != nil {
					return err
				}
			} else if err == ports.ErrNotFound {
				// Binding is new - use ValidateForCreation
				if err := bindingValidator.ValidateForCreation(ctx, *binding); err != nil {
					return err
				}
			} else {
				// Other error occurred
				return errors.Wrap(err, "failed to get network binding")
			}
		}
	}

	// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ scope
	var scope ports.Scope
	if len(bindings) > 0 {
		var ids []models.ResourceIdentifier
		for _, binding := range bindings {
			ids = append(ids, models.ResourceIdentifier{Name: binding.Name, Namespace: binding.Namespace})
		}
		scope = ports.NewResourceIdentifierScope(ids...)
	} else {
		scope = ports.EmptyScope{}
	}

	log.Printf("üîÑ DEBUG: syncNetworkBindings - Starting to sync %d NetworkBindings with operation: %s", len(bindings), syncOp)

	// 1. –°–Ω–∞—á–∞–ª–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ–º NetworkBindings –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
	if err := writer.SyncNetworkBindings(ctx, bindings, scope, ports.WithSyncOp(syncOp)); err != nil {
		return errors.Wrap(err, "failed to sync network bindings")
	}
	log.Printf("‚úÖ DEBUG: syncNetworkBindings - Successfully synced NetworkBindings to transaction")

	// 2. –ü–æ–ª—É—á–∞–µ–º reader –∫–æ—Ç–æ—Ä—ã–π –≤–∏–¥–∏—Ç –Ω–µ–∑–∞–∫–æ–º–º–∏—á–µ–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ç–µ–∫—É—â–µ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
	txReader, err := s.registry.ReaderFromWriter(ctx, writer)
	if err != nil {
		return errors.Wrap(err, "failed to get transaction reader")
	}
	defer txReader.Close()
	log.Printf("‚úÖ DEBUG: syncNetworkBindings - Got transaction reader")

	// 3. –í –¢–û–ô –ñ–ï —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ Network –∏ AddressGroup
	var networksToSync []models.Network
	var addressGroupsToSync []models.AddressGroup

	if syncOp != models.SyncOpDelete {
		log.Printf("üîÑ DEBUG: syncNetworkBindings - Processing %d bindings for Network and AddressGroup updates IN SAME TRANSACTION", len(bindings))

		for _, binding := range bindings {
			log.Printf("üîÑ DEBUG: syncNetworkBindings - Processing binding %s", binding.Key())

			// –û–±–Ω–æ–≤–ª—è–µ–º Network –≤ —Ç–æ–π –∂–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
			networkRef := models.ResourceIdentifier{Name: binding.NetworkRef.Name, Namespace: binding.Namespace}
			log.Printf("üîÑ DEBUG: syncNetworkBindings - Getting Network %s", networkRef.Key())

			network, err := txReader.GetNetworkByID(ctx, networkRef)
			if err != nil {
				return errors.Wrapf(err, "failed to get network %s", networkRef.Key())
			}
			log.Printf("‚úÖ DEBUG: syncNetworkBindings - Found Network %s, updating binding references", network.Key())

			// –û–±–Ω–æ–≤–ª—è–µ–º Network —Å binding references
			network.BindingRef = &v1beta1.ObjectReference{
				APIVersion: "netguard.sgroups.io/v1beta1",
				Kind:       "NetworkBinding",
				Name:       binding.Name,
			}
			network.AddressGroupRef = &v1beta1.ObjectReference{
				APIVersion: "netguard.sgroups.io/v1beta1",
				Kind:       "AddressGroup",
				Name:       binding.AddressGroupRef.Name,
			}
			network.IsBound = true
			network.Meta.TouchOnWrite(fmt.Sprintf("binding-%d", time.Now().UnixNano()))

			// –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π Network –≤ —Ç–æ–π –∂–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
			log.Printf("üîÑ DEBUG: syncNetworkBindings - About to call writer.SyncNetworks for %s", network.Key())
			log.Printf("üîÑ DEBUG: syncNetworkBindings - Network details: IsBound=%t, BindingRef=%v, AddressGroupRef=%v",
				network.IsBound, network.BindingRef, network.AddressGroupRef)
			if err := writer.SyncNetworks(ctx, []models.Network{*network}, ports.NewResourceIdentifierScope(networkRef)); err != nil {
				return errors.Wrapf(err, "failed to sync network %s in transaction", networkRef.Key())
			}
			networksToSync = append(networksToSync, *network)
			log.Printf("‚úÖ DEBUG: syncNetworkBindings - Updated Network %s in transaction (should be in writer now)", network.Key())

			// –û–±–Ω–æ–≤–ª—è–µ–º AddressGroup –≤ —Ç–æ–π –∂–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
			addressGroupRef := models.ResourceIdentifier{Name: binding.AddressGroupRef.Name, Namespace: binding.Namespace}
			log.Printf("üîÑ DEBUG: syncNetworkBindings - Getting AddressGroup %s", addressGroupRef.Key())

			addressGroup, err := txReader.GetAddressGroupByID(ctx, addressGroupRef)
			if err != nil {
				return errors.Wrapf(err, "failed to get address group %s", addressGroupRef.Key())
			}
			log.Printf("‚úÖ DEBUG: syncNetworkBindings - Found AddressGroup %s, checking if Network already in Networks list", addressGroup.Key())

			// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ Network –≤ AddressGroup
			networkName := fmt.Sprintf("%s/%s", network.Namespace, network.Name)
			networkExists := false
			for _, item := range addressGroup.Networks {
				if item.Name == networkName {
					networkExists = true
					break
				}
			}

			if !networkExists {
				log.Printf("üîÑ DEBUG: syncNetworkBindings - Adding Network %s to AddressGroup %s Networks list", networkName, addressGroup.Key())

				// –î–æ–±–∞–≤–ª—è–µ–º Network –≤ AddressGroup
				networkItem := models.NetworkItem{
					Name:       networkName,
					CIDR:       network.CIDR,
					ApiVersion: "netguard.sgroups.io/v1beta1",
					Kind:       "Network",
					Namespace:  network.Namespace,
				}
				addressGroup.Networks = append(addressGroup.Networks, networkItem)
				addressGroup.Meta.TouchOnWrite(fmt.Sprintf("binding-%d", time.Now().UnixNano()))

				// –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π AddressGroup –≤ —Ç–æ–π –∂–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
				log.Printf("üîÑ DEBUG: syncNetworkBindings - About to call writer.SyncAddressGroups for %s", addressGroup.Key())
				log.Printf("üîÑ DEBUG: syncNetworkBindings - AddressGroup Networks count: %d", len(addressGroup.Networks))
				if err := writer.SyncAddressGroups(ctx, []models.AddressGroup{*addressGroup}, ports.NewResourceIdentifierScope(addressGroupRef)); err != nil {
					return errors.Wrapf(err, "failed to sync address group %s in transaction", addressGroupRef.Key())
				}
				addressGroupsToSync = append(addressGroupsToSync, *addressGroup)
				log.Printf("‚úÖ DEBUG: syncNetworkBindings - Updated AddressGroup %s in transaction (should be in writer now)", addressGroup.Key())
			} else {
				log.Printf("‚ÑπÔ∏è  DEBUG: syncNetworkBindings - Network %s already exists in AddressGroup %s", networkName, addressGroup.Key())
				addressGroupsToSync = append(addressGroupsToSync, *addressGroup)
			}
		}
	} else {
		log.Printf("üîÑ DEBUG: syncNetworkBindings - Processing %d bindings for deletion IN SAME TRANSACTION", len(bindings))

		for _, binding := range bindings {
			log.Printf("üîÑ DEBUG: syncNetworkBindings - Processing deletion for binding %s", binding.Key())

			// –û—á–∏—â–∞–µ–º references –≤ Network
			networkRef := models.ResourceIdentifier{Name: binding.NetworkRef.Name, Namespace: binding.Namespace}
			network, err := txReader.GetNetworkByID(ctx, networkRef)
			if err != nil {
				if err == ports.ErrNotFound {
					log.Printf("‚ö†Ô∏è  DEBUG: syncNetworkBindings - Network %s not found for deletion, skipping", networkRef.Key())
				} else {
					return errors.Wrapf(err, "failed to get network %s for deletion", networkRef.Key())
				}
			} else {
				log.Printf("üîÑ DEBUG: syncNetworkBindings - Clearing binding references in Network %s", network.Key())

				// –û—á–∏—â–∞–µ–º binding references
				network.BindingRef = nil
				network.AddressGroupRef = nil
				network.IsBound = false
				network.Meta.TouchOnWrite(fmt.Sprintf("unbinding-%d", time.Now().UnixNano()))

				if err := writer.SyncNetworks(ctx, []models.Network{*network}, ports.NewResourceIdentifierScope(networkRef)); err != nil {
					return errors.Wrapf(err, "failed to sync network %s for deletion", networkRef.Key())
				}
				networksToSync = append(networksToSync, *network)
				log.Printf("‚úÖ DEBUG: syncNetworkBindings - Cleared Network %s references in transaction", network.Key())
			}

			// –£–¥–∞–ª—è–µ–º Network –∏–∑ AddressGroup
			addressGroupRef := models.ResourceIdentifier{Name: binding.AddressGroupRef.Name, Namespace: binding.Namespace}
			addressGroup, err := txReader.GetAddressGroupByID(ctx, addressGroupRef)
			if err != nil {
				if err == ports.ErrNotFound {
					log.Printf("‚ö†Ô∏è  DEBUG: syncNetworkBindings - AddressGroup %s not found for deletion, skipping", addressGroupRef.Key())
				} else {
					return errors.Wrapf(err, "failed to get address group %s for deletion", addressGroupRef.Key())
				}
			} else {
				log.Printf("üîÑ DEBUG: syncNetworkBindings - Removing Network from AddressGroup %s", addressGroup.Key())

				// –£–¥–∞–ª—è–µ–º Network –∏–∑ AddressGroup (–∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç namespace/name)
				networkName := fmt.Sprintf("%s/%s", binding.Namespace, binding.NetworkRef.Name)
				var updatedNetworks []models.NetworkItem
				removedCount := 0
				for _, item := range addressGroup.Networks {
					if item.Name != networkName {
						updatedNetworks = append(updatedNetworks, item)
					} else {
						removedCount++
					}
				}

				if removedCount > 0 {
					addressGroup.Networks = updatedNetworks
					addressGroup.Meta.TouchOnWrite(fmt.Sprintf("unbinding-%d", time.Now().UnixNano()))

					if err := writer.SyncAddressGroups(ctx, []models.AddressGroup{*addressGroup}, ports.NewResourceIdentifierScope(addressGroupRef)); err != nil {
						return errors.Wrapf(err, "failed to sync address group %s for deletion", addressGroupRef.Key())
					}
					addressGroupsToSync = append(addressGroupsToSync, *addressGroup)
					log.Printf("‚úÖ DEBUG: syncNetworkBindings - Removed Network %s from AddressGroup %s in transaction", networkName, addressGroup.Key())
				} else {
					log.Printf("‚ÑπÔ∏è  DEBUG: syncNetworkBindings - Network %s not found in AddressGroup %s", networkName, addressGroup.Key())
					addressGroupsToSync = append(addressGroupsToSync, *addressGroup)
				}
			}
		}
	}

	// 4. –ö–æ–º–º–∏—Ç–∏–º –í–°–ï –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–æ–º (NetworkBindings + Networks + AddressGroups)
	log.Printf("üîÑ DEBUG: syncNetworkBindings - About to commit transaction")
	log.Printf("üîÑ DEBUG: syncNetworkBindings - Expected to commit %d Networks and %d AddressGroups", len(networksToSync), len(addressGroupsToSync))
	if err := writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit all changes")
	}
	log.Printf("‚úÖ DEBUG: syncNetworkBindings - Successfully committed all changes")

	// 5. –ü–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –∫–æ–º–º–∏—Ç–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Å SGROUP
	if len(networksToSync) > 0 {
		log.Printf("üîÑ DEBUG: syncNetworkBindings - Syncing %d Networks with SGROUP (FORCED)", len(networksToSync))
		networkSyncResults := s.syncNetworksWithSGroupsForced(ctx, networksToSync, types.SyncOperationUpsert)
		log.Printf("‚úÖ DEBUG: syncNetworkBindings - Completed Networks sync with SGROUP")

		// –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
		for _, network := range networksToSync {
			if err := networkSyncResults[network.GetSyncKey()]; err != nil {
				log.Printf("‚ùå ERROR: syncNetworkBindings - Network %s sync failed: %v", network.GetSyncKey(), err)
			}
		}
	}

	if len(addressGroupsToSync) > 0 {
		log.Printf("üîÑ DEBUG: syncNetworkBindings - Syncing %d AddressGroups with SGROUP (FORCED)", len(addressGroupsToSync))
		s.syncAddressGroupsWithSGroupsForced(ctx, addressGroupsToSync, types.SyncOperationUpsert)
		log.Printf("‚úÖ DEBUG: syncNetworkBindings - Completed AddressGroups sync with SGROUP")
	}

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ conditions
	s.processConditionsIfNeeded(ctx, bindings, syncOp)
	return nil
}

// GenerateIEAgAgRulesFromRuleS2S –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–∞–≤–∏–ª–∞ IEAgAgRule –Ω–∞ –æ—Å–Ω–æ–≤–µ RuleS2S
func (s *NetguardService) GenerateIEAgAgRulesFromRuleS2S(ctx context.Context, ruleS2S models.RuleS2S) ([]models.IEAgAgRule, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	return s.GenerateIEAgAgRulesFromRuleS2SWithReader(ctx, reader, ruleS2S)
}

// GenerateIEAgAgRulesFromRuleS2SWithReader –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–∞–≤–∏–ª–∞ IEAgAgRule –Ω–∞ –æ—Å–Ω–æ–≤–µ RuleS2S, –∏—Å–ø–æ–ª—å–∑—É—è –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π reader
func (s *NetguardService) GenerateIEAgAgRulesFromRuleS2SWithReader(ctx context.Context, reader ports.Reader, ruleS2S models.RuleS2S) ([]models.IEAgAgRule, error) {
	klog.Infof("üî• DEBUG: GenerateIEAgAgRulesFromRuleS2SWithReader called for RuleS2S: %s (traffic: %s)", ruleS2S.Key(), ruleS2S.Traffic)
	klog.Infof("üî• DEBUG: RuleS2S references - local: %s, target: %s", ruleS2S.ServiceLocalRef.Key(), ruleS2S.ServiceRef.Key())

	// –ü–æ–ª—É—á–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã –ø–æ —Å—Å—ã–ª–∫–∞–º
	localServiceAlias, err := reader.GetServiceAliasByID(ctx, ruleS2S.ServiceLocalRef.ResourceIdentifier)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to get local service alias %s", ruleS2S.ServiceLocalRef.Key())
	}

	targetServiceAlias, err := reader.GetServiceAliasByID(ctx, ruleS2S.ServiceRef.ResourceIdentifier)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to get target service alias %s", ruleS2S.ServiceRef.Key())
	}

	localService, err := reader.GetServiceByID(ctx, localServiceAlias.ServiceRef.ResourceIdentifier)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to get local service %s", localServiceAlias.ServiceRef.Key())
	}
	klog.Infof("üî• DEBUG: Retrieved localService %s from DB: %d IngressPorts", localService.Key(), len(localService.IngressPorts))
	for i, port := range localService.IngressPorts {
		klog.Infof("üî• DEBUG: localService.IngressPorts[%d]: %s/%s", i, port.Port, port.Protocol)
	}

	targetService, err := reader.GetServiceByID(ctx, targetServiceAlias.ServiceRef.ResourceIdentifier)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to get target service %s", targetServiceAlias.ServiceRef.Key())
	}
	klog.Infof("üî• DEBUG: Retrieved targetService %s from DB: %d IngressPorts", targetService.Key(), len(targetService.IngressPorts))
	for i, port := range targetService.IngressPorts {
		klog.Infof("üî• DEBUG: targetService.IngressPorts[%d]: %s/%s", i, port.Port, port.Protocol)
	}

	// –ü–æ–ª—É—á–∞–µ–º –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤
	localAddressGroups := localService.AddressGroups
	targetAddressGroups := targetService.AddressGroups

	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ—Ä—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç—Ä–∞—Ñ–∏–∫–∞
	klog.Infof("üî• DEBUG: RuleS2S %s - localService: %s (ports: %d), targetService: %s (ports: %d)",
		ruleS2S.Key(), localService.Key(), len(localService.IngressPorts), targetService.Key(), len(targetService.IngressPorts))

	for i, port := range localService.IngressPorts {
		klog.Infof("üî• DEBUG: localService.IngressPorts[%d]: %s/%s", i, port.Port, port.Protocol)
	}
	for i, port := range targetService.IngressPorts {
		klog.Infof("üî• DEBUG: targetService.IngressPorts[%d]: %s/%s", i, port.Port, port.Protocol)
	}

	var ports []models.IngressPort
	if ruleS2S.Traffic == models.INGRESS {
		ports = localService.IngressPorts
		klog.Infof("üî• DEBUG: Using localService ports for INGRESS traffic: %d ports", len(ports))
	} else {
		ports = targetService.IngressPorts
		klog.Infof("üî• DEBUG: Using targetService ports for EGRESS traffic: %d ports", len(ports))
	}

	klog.Infof("üî• DEBUG: Final ports array: %v", ports)

	// –°–æ–∑–¥–∞–µ–º –ø—Ä–∞–≤–∏–ª–∞ IEAgAgRule
	var result []models.IEAgAgRule

	// –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ—Ä—Ç—ã –ø–æ –ø—Ä–æ—Ç–æ–∫–æ–ª—É
	tcpPorts := []string{}
	udpPorts := []string{}

	for _, port := range ports {
		if port.Protocol == models.TCP {
			tcpPorts = append(tcpPorts, port.Port)
		} else if port.Protocol == models.UDP {
			udpPorts = append(udpPorts, port.Port)
		}
	}

	// –°–æ–∑–¥–∞–µ–º –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –∫–∞–∂–¥–æ–π –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –≥—Ä—É–ø–ø –∞–¥—Ä–µ—Å–æ–≤ –∏ –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–≤
	for _, localAG := range localAddressGroups {
		for _, targetAG := range targetAddressGroups {
			// –°–æ–∑–¥–∞–µ–º TCP –ø—Ä–∞–≤–∏–ª–æ
			if len(tcpPorts) > 0 {
				tcpRule := models.IEAgAgRule{
					SelfRef: models.SelfRef{
						ResourceIdentifier: models.NewResourceIdentifier(
							generateRuleName(string(ruleS2S.Traffic), localAG.Name, targetAG.Name, string(models.TCP)),
							models.WithNamespace(determineRuleNamespace(ruleS2S, localAG, targetAG)),
						),
					},
					Transport:         models.TCP,
					Traffic:           ruleS2S.Traffic,
					AddressGroupLocal: localAG,
					AddressGroup:      targetAG,
					Ports: []models.PortSpec{
						{
							Destination: strings.Join(tcpPorts, ","),
						},
					},
					Action:   models.ActionAccept,
					Logs:     true,
					Trace:    ruleS2S.Trace, // –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º trace –∏–∑ RuleS2S
					Priority: 100,
				}
				result = append(result, tcpRule)
			}

			// –°–æ–∑–¥–∞–µ–º UDP –ø—Ä–∞–≤–∏–ª–æ
			if len(udpPorts) > 0 {
				udpRule := models.IEAgAgRule{
					SelfRef: models.SelfRef{
						ResourceIdentifier: models.NewResourceIdentifier(
							generateRuleName(string(ruleS2S.Traffic), localAG.Name, targetAG.Name, string(models.UDP)),
							models.WithNamespace(determineRuleNamespace(ruleS2S, localAG, targetAG)),
						),
					},
					Transport:         models.UDP,
					Traffic:           ruleS2S.Traffic,
					AddressGroupLocal: localAG,
					AddressGroup:      targetAG,
					Ports: []models.PortSpec{
						{
							Destination: strings.Join(udpPorts, ","),
						},
					},
					Action:   models.ActionAccept,
					Logs:     true,
					Trace:    ruleS2S.Trace, // –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º trace –∏–∑ RuleS2S
					Priority: 100,
				}
				result = append(result, udpRule)
			}
		}
	}

	return result, nil
}

// generateRuleName —Å–æ–∑–¥–∞–µ—Ç –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–º—è –ø—Ä–∞–≤–∏–ª–∞
func generateRuleName(trafficDirection, localAGName, targetAGName, protocol string) string {
	input := fmt.Sprintf("%s-%s-%s-%s",
		strings.ToLower(trafficDirection),
		localAGName,
		targetAGName,
		strings.ToLower(protocol))

	h := sha256.New()
	h.Write([]byte(input))
	hash := h.Sum(nil)

	// –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –ø–µ—Ä–≤—ã–µ 16 –±–∞–π—Ç –∫–∞–∫ UUID v5
	uuid := fmt.Sprintf("%x-%x-%x-%x-%x",
		hash[0:4], hash[4:6], hash[6:8], hash[8:10], hash[10:16])

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç—Ä–∞—Ñ–∏–∫–∞ –∏ UUID
	return fmt.Sprintf("%s-%s",
		strings.ToLower(trafficDirection)[:3],
		uuid)
}

// determineRuleNamespace –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∏–º–µ–Ω –¥–ª—è –ø—Ä–∞–≤–∏–ª–∞
func determineRuleNamespace(ruleS2S models.RuleS2S, localAG, targetAG models.AddressGroupRef) string {
	if ruleS2S.Traffic == models.INGRESS {
		// –î–ª—è –≤—Ö–æ–¥—è—â–µ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞ –ø—Ä–∞–≤–∏–ª–æ —Ä–∞–∑–º–µ—â–∞–µ—Ç—Å—è –≤ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –∏–º–µ–Ω –ª–æ–∫–∞–ª—å–Ω–æ–π –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤
		if localAG.Namespace != "" {
			return localAG.Namespace
		}
		return ruleS2S.Namespace
	} else {
		// –î–ª—è –∏—Å—Ö–æ–¥—è—â–µ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞ –ø—Ä–∞–≤–∏–ª–æ —Ä–∞–∑–º–µ—â–∞–µ—Ç—Å—è –≤ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –∏–º–µ–Ω —Ü–µ–ª–µ–≤–æ–π –≥—Ä—É–ø–ø—ã –∞–¥—Ä–µ—Å–æ–≤
		if targetAG.Namespace != "" {
			return targetAG.Namespace
		}
		return ruleS2S.Namespace
	}
}

// SyncIEAgAgRules —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–∞–≤–∏–ª–∞ IEAgAgRule
func (s *NetguardService) SyncIEAgAgRules(ctx context.Context, rules []models.IEAgAgRule, scope ports.Scope) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator
	validator := validation.NewDependencyValidator(reader)
	ruleValidator := validator.GetIEAgAgRuleValidator()

	// Validate all rules
	for _, rule := range rules {
		// Check if rule exists
		existingRule, err := reader.GetIEAgAgRuleByID(ctx, rule.ResourceIdentifier)
		if err == nil {
			// Rule exists - use ValidateForUpdate
			if err := ruleValidator.ValidateForUpdate(ctx, *existingRule, rule); err != nil {
				return err
			}
		} else {
			// Rule is new - use ValidateForCreation
			if err := ruleValidator.ValidateForCreation(ctx, rule); err != nil {
				return err
			}
		}
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = s.syncIEAgAgRules(ctx, writer, rules, models.SyncOpFullSync); err != nil {
		return errors.Wrap(err, "failed to sync IEAgAgRules")
	}
	return nil
}

// SyncNetworks —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç —Å–µ—Ç–∏
func (s *NetguardService) SyncNetworks(ctx context.Context, networks []models.Network, scope ports.Scope) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator for Network validation
	validator := validation.NewDependencyValidator(reader)
	networkValidator := validator.GetNetworkValidator()

	// Validate all networks
	for i := range networks {
		network := &networks[i]

		// Check if network exists
		networkID := models.ResourceIdentifier{Name: network.Name, Namespace: network.Namespace}
		existingNetwork, err := reader.GetNetworkByID(ctx, networkID)
		if err == nil {
			// Network exists - use ValidateForUpdate
			if err := networkValidator.ValidateForUpdate(ctx, *existingNetwork, *network); err != nil {
				return err
			}
		} else if err == ports.ErrNotFound {
			// Network is new - use ValidateForCreation
			if err := networkValidator.ValidateForCreation(ctx, *network); err != nil {
				return err
			}
		} else {
			// Other error occurred
			return errors.Wrap(err, "failed to get network")
		}
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.SyncNetworks(ctx, networks, scope, ports.WithSyncOp(models.SyncOpFullSync)); err != nil {
		return errors.Wrap(err, "failed to sync networks")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å sgroups –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ commit'–∞
	log.Printf("üîß DEBUG: SyncNetworks - Starting sgroups synchronization for %d Networks", len(networks))
	sgroupsSyncResults := s.syncNetworksWithSGroups(ctx, networks, types.SyncOperationUpsert)
	log.Printf("‚úÖ DEBUG: SyncNetworks - Completed sgroups synchronization")

	for i := range networks {
		network := &networks[i]
		syncResult := sgroupsSyncResults[network.GetSyncKey()]
		s.conditionManager.ProcessNetworkConditions(ctx, network, syncResult)
		if err := s.conditionManager.saveResourceConditions(ctx, network); err != nil {
			log.Printf("Failed to save network conditions for %s: %v", network.Key(), err)
		}
	}
	return nil
}

// SyncNetworkBindings —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–∏–≤—è–∑–∫–∏ —Å–µ—Ç–µ–π
func (s *NetguardService) SyncNetworkBindings(ctx context.Context, bindings []models.NetworkBinding, scope ports.Scope) error {
	log.Printf("üö® DEBUG: SyncNetworkBindings PUBLIC METHOD CALLED with %d bindings", len(bindings))
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator for NetworkBinding validation
	validator := validation.NewDependencyValidator(reader)
	bindingValidator := validator.GetNetworkBindingValidator()

	// Validate all bindings
	for i := range bindings {
		binding := &bindings[i]

		// Check if binding exists
		bindingID := models.ResourceIdentifier{Name: binding.Name, Namespace: binding.Namespace}
		existingBinding, err := reader.GetNetworkBindingByID(ctx, bindingID)
		if err == nil {
			// Binding exists - use ValidateForUpdate
			if err := bindingValidator.ValidateForUpdate(ctx, *existingBinding, *binding); err != nil {
				return err
			}
		} else if err == ports.ErrNotFound {
			// Binding is new - use ValidateForCreation
			if err := bindingValidator.ValidateForCreation(ctx, *binding); err != nil {
				return err
			}
		} else {
			// Other error occurred
			return errors.Wrap(err, "failed to get network binding")
		}
	}

	// Use the same logic as the general Sync method for consistency
	// This ensures atomic updates of NetworkBinding, Network, and AddressGroup
	log.Printf("üîÑ DEBUG: SyncNetworkBindings - Using unified sync logic for %d NetworkBindings", len(bindings))

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	// Use the internal syncNetworkBindings method that handles atomicity
	if err := s.syncNetworkBindings(ctx, writer, bindings, models.SyncOpFullSync); err != nil {
		return err
	}

	// NOTE: We do NOT call processConditionsIfNeeded here because syncNetworkBindings
	// already handles condition processing within the same transaction.
	// Calling it here would create a separate commit that overwrites our atomic changes.

	log.Printf("‚úÖ DEBUG: SyncNetworkBindings - Successfully completed unified sync for %d NetworkBindings", len(bindings))
	return nil
}

// DeleteIEAgAgRulesByIDs deletes IEAgAgRules by IDs
func (s *NetguardService) DeleteIEAgAgRulesByIDs(ctx context.Context, ids []models.ResourceIdentifier) error {
	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.DeleteIEAgAgRulesByIDs(ctx, ids); err != nil {
		return errors.Wrap(err, "failed to delete IEAgAgRules")
	}

	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	return nil
}

// GetIEAgAgRulesByIDs returns a list of IEAgAgRules by IDs
func (s *NetguardService) GetIEAgAgRulesByIDs(ctx context.Context, ids []models.ResourceIdentifier) ([]models.IEAgAgRule, error) {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	var result []models.IEAgAgRule

	for _, id := range ids {
		rule, err := reader.GetIEAgAgRuleByID(ctx, id)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to get IEAgAgRule %s", id.Key())
		}
		if rule != nil {
			result = append(result, *rule)
		}
	}

	return result, nil
}

// DeleteAddressGroupBindingPoliciesByIDs deletes address group binding policies by IDs
func (s *NetguardService) DeleteAddressGroupBindingPoliciesByIDs(ctx context.Context, ids []models.ResourceIdentifier) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator
	validator := validation.NewAddressGroupBindingPolicyValidator(reader)

	// Check dependencies for each policy
	for _, id := range ids {
		if err := validator.CheckDependencies(ctx, id); err != nil {
			return err
		}
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.DeleteAddressGroupBindingPoliciesByIDs(ctx, ids); err != nil {
		return errors.Wrap(err, "failed to delete address group binding policies")
	}
	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}
	return nil
}

// DeleteNetworksByIDs deletes networks by IDs
func (s *NetguardService) DeleteNetworksByIDs(ctx context.Context, ids []models.ResourceIdentifier) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Get networks that will be deleted (for syncing with SGROUP after deletion)
	var networks []models.Network
	for _, id := range ids {
		network, err := reader.GetNetworkByID(ctx, id)
		if err != nil {
			continue // Skip if network doesn't exist
		}
		networks = append(networks, *network)
	}

	// Create validator for dependency checking
	validator := validation.NewDependencyValidator(reader)
	networkValidator := validator.GetNetworkValidator()

	// Check dependencies for each network
	for _, id := range ids {
		if err := networkValidator.CheckDependencies(ctx, id); err != nil {
			return err
		}
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.DeleteNetworksByIDs(ctx, ids); err != nil {
		return errors.Wrap(err, "failed to delete networks")
	}

	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å sgroups –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –ë–î
	if len(networks) > 0 {
		log.Printf("üîß DEBUG: DeleteNetworksByIDs - Starting sgroups synchronization for %d deleted Networks", len(networks))
		deleteSyncResults := s.syncNetworksWithSGroups(ctx, networks, types.SyncOperationDelete)
		log.Printf("‚úÖ DEBUG: DeleteNetworksByIDs - Completed sgroups synchronization")

		// –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ —É–¥–∞–ª–µ–Ω–∏—è –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
		for _, network := range networks {
			if err := deleteSyncResults[network.GetSyncKey()]; err != nil {
				log.Printf("‚ùå ERROR: DeleteNetworksByIDs - Network %s delete sync failed: %v", network.GetSyncKey(), err)
			}
		}
	}

	return nil
}

// DeleteNetworkBindingsByIDs deletes network bindings by IDs
func (s *NetguardService) DeleteNetworkBindingsByIDs(ctx context.Context, ids []models.ResourceIdentifier) error {
	reader, err := s.registry.Reader(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get reader")
	}
	defer reader.Close()

	// Create validator for dependency checking
	validator := validation.NewDependencyValidator(reader)
	bindingValidator := validator.GetNetworkBindingValidator()

	// Check dependencies for each network binding
	for _, id := range ids {
		if err := bindingValidator.CheckDependencies(ctx, id); err != nil {
			return err
		}
	}

	writer, err := s.registry.Writer(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to get writer")
	}
	defer func() {
		if err != nil {
			writer.Abort()
		}
	}()

	if err = writer.DeleteNetworkBindingsByIDs(ctx, ids); err != nil {
		return errors.Wrap(err, "failed to delete network bindings")
	}

	if err = writer.Commit(); err != nil {
		return errors.Wrap(err, "failed to commit")
	}

	return nil
}

// servicePortsChanged –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, –∏–∑–º–µ–Ω–∏–ª–∏—Å—å –ª–∏ –ø–æ—Ä—Ç—ã –º–µ–∂–¥—É —Å—Ç–∞—Ä–æ–π –∏ –Ω–æ–≤–æ–π –≤–µ—Ä—Å–∏–µ–π —Å–µ—Ä–≤–∏—Å–∞
func (s *NetguardService) servicePortsChanged(oldService, newService models.Service) bool {
	// –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ä—Ç–æ–≤
	if len(oldService.IngressPorts) != len(newService.IngressPorts) {
		log.Printf("Service %s: port count changed from %d to %d", newService.Key(), len(oldService.IngressPorts), len(newService.IngressPorts))
		return true
	}

	// –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É –ø–æ—Ä—Ç–æ–≤ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
	oldPortsMap := make(map[string]models.TransportProtocol)
	for _, port := range oldService.IngressPorts {
		oldPortsMap[port.Port] = port.Protocol
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –Ω–æ–≤—ã–µ –ø–æ—Ä—Ç—ã –µ—Å—Ç—å –≤ —Å—Ç–∞—Ä—ã—Ö —Å —Ç–µ–º –∂–µ –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–º
	for _, port := range newService.IngressPorts {
		if oldProtocol, exists := oldPortsMap[port.Port]; !exists || oldProtocol != port.Protocol {
			log.Printf("Service %s: port %s protocol changed from %s to %s",
				newService.Key(), port.Port, oldProtocol, port.Protocol)
			return true
		}
	}

	log.Printf("Service %s: ports unchanged", newService.Key())
	return false
}

// CompareServicePorts —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –ø–æ—Ä—Ç—ã –º–µ–∂–¥—É —Å—Ç–∞—Ä–æ–π –∏ –Ω–æ–≤–æ–π –≤–µ—Ä—Å–∏–µ–π —Å–µ—Ä–≤–∏—Å–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç diff
func CompareServicePorts(oldPorts, newPorts []models.IngressPort) (added, removed []models.IngressPort) {
	oldPortSet := make(map[string]models.IngressPort)
	newPortSet := make(map[string]models.IngressPort)

	// –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—ã –ø–æ—Ä—Ç–æ–≤ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ (–∫–ª—é—á: port/protocol)
	for _, port := range oldPorts {
		key := port.Port + "/" + string(port.Protocol)
		oldPortSet[key] = port
	}
	for _, port := range newPorts {
		key := port.Port + "/" + string(port.Protocol)
		newPortSet[key] = port
	}

	// –ù–∞—Ö–æ–¥–∏–º –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –ø–æ—Ä—Ç—ã (–µ—Å—Ç—å –≤ new, –Ω–µ—Ç –≤ old)
	for key, port := range newPortSet {
		if _, exists := oldPortSet[key]; !exists {
			added = append(added, port)
		}
	}

	// –ù–∞—Ö–æ–¥–∏–º —É–¥–∞–ª–µ–Ω–Ω—ã–µ –ø–æ—Ä—Ç—ã (–µ—Å—Ç—å –≤ old, –Ω–µ—Ç –≤ new)
	for key, port := range oldPortSet {
		if _, exists := newPortSet[key]; !exists {
			removed = append(removed, port)
		}
	}

	return added, removed
}

// ServicePortDiff —Å–æ–¥–µ—Ä–∂–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö –ø–æ—Ä—Ç–æ–≤ —Å–µ—Ä–≤–∏—Å–∞
type ServicePortDiff struct {
	ServiceID    models.ResourceIdentifier
	AddedPorts   []models.IngressPort
	RemovedPorts []models.IngressPort
	IsNewService bool
}

// ContributingRule –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç RuleS2S –∫–æ—Ç–æ—Ä–∞—è –≤–Ω–æ—Å–∏—Ç –≤–∫–ª–∞–¥ –≤ –∞–≥—Ä–µ–≥–∞—Ü–∏—é –ø–æ—Ä—Ç–æ–≤
type ContributingRule struct {
	RuleS2S *models.RuleS2S
	Ports   []models.IngressPort // –ü–æ–ª–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ—Ä—Ç–∞—Ö —Å –ø—Ä–æ—Ç–æ–∫–æ–ª–∞–º–∏
}

// findContributingRuleS2S –Ω–∞—Ö–æ–¥–∏—Ç –≤—Å–µ RuleS2S –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –≤–Ω–æ—Å–∏—Ç—å –≤–∫–ª–∞–¥ –≤ –æ–¥–∏–Ω IEAgAgRule
func (s *NetguardService) findContributingRuleS2S(
	ctx context.Context,
	reader ports.Reader,
	currentRule models.RuleS2S,
	localService models.Service,
	targetService models.Service,
) ([]ContributingRule, error) {
	klog.Infof("üî• CONTRIBUTING_SEARCH: Starting search for rules contributing to %s", currentRule.Key())
	klog.Infof("    üî• CURRENT SERVICES: local=%s target=%s", localService.Key(), targetService.Key())
	klog.Infof("    üî• PROTECTION ENABLED: Will check if current service has ports to prevent obsolete rule creation!")
	klog.Infof("üîç CONTRIBUTING: Finding contributing RuleS2S for rule %s", currentRule.Key())
	klog.Infof("üîç CONTRIBUTING: localService=%s, targetService=%s", localService.Key(), targetService.Key())

	// –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ RuleS2S –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
	var allRules []models.RuleS2S
	err := reader.ListRuleS2S(ctx, func(rule models.RuleS2S) error {
		allRules = append(allRules, rule)
		return nil
	}, nil)
	if err != nil {
		return nil, errors.Wrap(err, "failed to list RuleS2S")
	}

	klog.Infof("üîç CONTRIBUTING: Found %d total RuleS2S in database", len(allRules))

	var contributingRules []ContributingRule
	var checkedRules, skippedRules, errorRules int

	for i, rule := range allRules {
		klog.Infof("  üîç CHECKING[%d/%d]: Rule %s (%s %s‚Üí%s)",
			i+1, len(allRules), rule.Key(), rule.Traffic,
			rule.ServiceLocalRef.Key(), rule.ServiceRef.Key())

		checkedRules++
		contributes, ports, err := s.checkIfRuleContributes(ctx, reader, rule, currentRule, localService, targetService)
		if err != nil {
			errorRules++
			klog.Errorf("üö® CONTRIBUTING: Error checking rule contribution for %s: %v", rule.Key(), err)
			continue
		}

		if contributes && len(ports) > 0 {
			var portStrs []string
			for _, p := range ports {
				portStrs = append(portStrs, fmt.Sprintf("%s/%s", p.Port, p.Protocol))
			}
			klog.Infof("üéØ CONTRIBUTING: Found contributing rule %s with %d ports: %s",
				rule.Key(), len(ports), strings.Join(portStrs, ","))

			contributingRules = append(contributingRules, ContributingRule{
				RuleS2S: &rule,
				Ports:   ports,
			})
		} else {
			skippedRules++
			if contributes {
				klog.Infof("  ‚ö†Ô∏è CONTRIBUTING: Rule %s contributes but has 0 ports", rule.Key())
			} else {
				klog.Infof("  ‚ûñ CONTRIBUTING: Rule %s does not contribute", rule.Key())
			}
		}
	}

	klog.Infof("üîç CONTRIBUTING: Summary for %s: checked=%d, contributing=%d, skipped=%d, errors=%d",
		currentRule.Key(), checkedRules, len(contributingRules), skippedRules, errorRules)
	return contributingRules, nil
}

// generateAGPairsForRule –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤—Å–µ AG –ø–∞—Ä—ã –¥–ª—è RuleS2S
func (s *NetguardService) generateAGPairsForRule(
	traffic models.Traffic,
	localService models.Service,
	targetService models.Service,
	protocol models.TransportProtocol,
) []string {
	klog.Infof("üîß AG_PAIRS: Generating AG pairs for %s local=%s(%d AGs) target=%s(%d AGs) protocol=%s",
		traffic, localService.Key(), len(localService.AddressGroups),
		targetService.Key(), len(targetService.AddressGroups), protocol)

	var agPairs []string
	for i, localAG := range localService.AddressGroups {
		for j, targetAG := range targetService.AddressGroups {
			agPair := fmt.Sprintf("%s|%s|%s|%s", traffic, localAG.Key(), targetAG.Key(), protocol)
			agPairs = append(agPairs, agPair)
			klog.Infof("  üîß AG_PAIRS[%d,%d]: %s ‚Üí %s = %s",
				i, j, localAG.Key(), targetAG.Key(), agPair)
		}
	}

	klog.Infof("üîß AG_PAIRS: Generated %d AG pairs total", len(agPairs))
	return agPairs
}

// checkIfRuleContributes –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ–ª–∂–Ω–∞ –ª–∏ RuleS2S –≤–Ω–æ—Å–∏—Ç—å –≤–∫–ª–∞–¥ –≤ –∞–≥—Ä–µ–≥–∞—Ü–∏—é –ø–æ AG –ø–∞—Ä–∞–º!
func (s *NetguardService) checkIfRuleContributes(
	ctx context.Context,
	reader ports.Reader,
	candidateRule models.RuleS2S,
	currentRule models.RuleS2S,
	localService models.Service,
	targetService models.Service,
) (bool, []models.IngressPort, error) {
	klog.Infof("üîç CONTRIBUTES: Checking if %s contributes to %s", candidateRule.Key(), currentRule.Key())

	// ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ 1: –û–¥–∏–Ω–∞–∫–æ–≤–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç—Ä–∞—Ñ–∏–∫–∞
	if candidateRule.Traffic != currentRule.Traffic {
		klog.Infof("  ‚ùå CONTRIBUTES: Different traffic direction: %s vs %s", candidateRule.Traffic, currentRule.Traffic)
		return false, nil, nil
	}
	klog.Infof("  ‚úÖ CONTRIBUTES: Same traffic direction: %s", candidateRule.Traffic)

	// ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ 2: –ü–æ–ª—É—á–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è candidate rule
	candidateLocalService, candidateTargetService, err := s.getServicesForRule(ctx, reader, candidateRule)
	if err != nil {
		klog.Errorf("  üö® CONTRIBUTES: Failed to get services for %s: %v", candidateRule.Key(), err)
		return false, nil, err
	}
	klog.Infof("  ‚úÖ CONTRIBUTES: Got candidate services: local=%s target=%s",
		candidateLocalService.Key(), candidateTargetService.Key())

	// ‚úÖ –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ AG –ø–∞—Ä –≤–º–µ—Å—Ç–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤!
	klog.Infof("  üîß CONTRIBUTES: Generating AG pairs for comparison...")

	// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º AG –ø–∞—Ä—ã –¥–ª—è currentRule (–¥–ª—è –ª—é–±–æ–≥–æ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º TCP –∫–∞–∫ –±–∞–∑–æ–≤—ã–π)
	klog.Infof("    üîß CURRENT_RULE AG pairs:")
	currentAGPairs := s.generateAGPairsForRule(currentRule.Traffic, localService, targetService, models.TCP)

	// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º AG –ø–∞—Ä—ã –¥–ª—è candidateRule
	klog.Infof("    üîß CANDIDATE_RULE AG pairs:")
	candidateAGPairs := s.generateAGPairsForRule(candidateRule.Traffic, *candidateLocalService, *candidateTargetService, models.TCP)

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –≤ AG –ø–∞—Ä–∞—Ö (—É–±–∏—Ä–∞–µ–º –ø—Ä–æ—Ç–æ–∫–æ–ª –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è)
	klog.Infof("  üîç CONTRIBUTES: Checking AG pairs intersection...")
	currentPairsSet := make(map[string]bool)
	for i, pair := range currentAGPairs {
		// –£–±–∏—Ä–∞–µ–º –ø—Ä–æ—Ç–æ–∫–æ–ª –∏–∑ –∫–ª—é—á–∞ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è (–∑–∞–º–µ–Ω—è–µ–º "|TCP" –Ω–∞ "")
		pairWithoutProtocol := strings.Replace(pair, "|TCP", "", 1)
		currentPairsSet[pairWithoutProtocol] = true
		klog.Infof("    üîç CURRENT_PAIRS[%d]: %s ‚Üí without protocol: %s", i, pair, pairWithoutProtocol)
	}

	hasIntersection := false
	var intersectedPairs []string
	for i, pair := range candidateAGPairs {
		// –£–±–∏—Ä–∞–µ–º –ø—Ä–æ—Ç–æ–∫–æ–ª –∏–∑ –∫–ª—é—á–∞ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
		pairWithoutProtocol := strings.Replace(pair, "|TCP", "", 1)
		klog.Infof("    üîç CANDIDATE_PAIRS[%d]: %s ‚Üí without protocol: %s", i, pair, pairWithoutProtocol)

		if currentPairsSet[pairWithoutProtocol] {
			hasIntersection = true
			intersectedPairs = append(intersectedPairs, pairWithoutProtocol)
			klog.Infof("      ‚úÖ INTERSECTION FOUND: %s", pairWithoutProtocol)
		} else {
			klog.Infof("      ‚ùå NO INTERSECTION: %s", pairWithoutProtocol)
		}
	}

	// –ï—Å–ª–∏ –Ω–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π AG –ø–∞—Ä - –Ω–µ contributing
	if !hasIntersection {
		klog.Infof("  ‚ùå CONTRIBUTES: No AG pairs intersection found ‚Üí NOT contributing")
		return false, nil, nil
	}

	klog.Infof("  ‚úÖ CONTRIBUTES: Found %d AG pairs intersections: %v ‚Üí IS contributing",
		len(intersectedPairs), intersectedPairs)

	// üî• –ü–†–û–í–ï–†–ö–ê 3: –ö–†–ò–¢–ò–ß–ù–û - –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –¢–ï–ö–£–©–ò–ô —Å–µ—Ä–≤–∏—Å –∏–º–µ–µ—Ç –ø–æ—Ä—Ç—ã!
	klog.Infof("  üîç CONTRIBUTES: Checking CURRENT service ports to prevent obsolete rule creation...")

	var currentServicePorts []models.IngressPort
	var currentServiceName string
	if currentRule.Traffic == models.INGRESS {
		currentServicePorts = s.extractPortsFromService(localService)
		currentServiceName = localService.Key()
		klog.Infof("    üîç CURRENT RULE: %s uses LOCAL service %s", currentRule.Key(), currentServiceName)
	} else {
		currentServicePorts = s.extractPortsFromService(targetService)
		currentServiceName = targetService.Key()
		klog.Infof("    üîç CURRENT RULE: %s uses TARGET service %s", currentRule.Key(), currentServiceName)
	}

	var currentPortStrs []string
	for _, p := range currentServicePorts {
		currentPortStrs = append(currentPortStrs, fmt.Sprintf("%s/%s", p.Port, p.Protocol))
	}
	klog.Infof("    üîç CURRENT SERVICE: %s has %d ports: %v",
		currentServiceName, len(currentServicePorts), currentPortStrs)

	// üö® –°–ú–Ø–ì–ß–ï–ù–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê: –õ–æ–≥–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–π —Å–µ—Ä–≤–∏—Å –Ω–æ –ù–ï –±–ª–æ–∫–∏—Ä—É–µ–º contributing rules
	if len(currentServicePorts) == 0 {
		klog.Infof("  ‚ö†Ô∏è CONTRIBUTES: Current service %s has 0 ports (will be filtered in aggregation)", currentServiceName)
	} else {
		klog.Infof("  ‚úÖ CONTRIBUTES: Current service %s has %d ports ‚Üí can contribute",
			currentServiceName, len(currentServicePorts))
	}

	// üî• –ü–†–û–í–ï–†–ö–ê 4: –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–æ—Ä—Ç—ã –∏–∑ candidate rule –¥–ª—è –∞–≥—Ä–µ–≥–∞—Ü–∏–∏
	klog.Infof("  üîç CONTRIBUTES: Now checking CANDIDATE service ports for aggregation...")

	var candidatePorts []models.IngressPort
	var candidateServiceName string
	if candidateRule.Traffic == models.INGRESS {
		candidatePorts = s.extractPortsFromService(*candidateLocalService)
		candidateServiceName = candidateLocalService.Key()
		klog.Infof("    üîç CANDIDATE RULE: %s uses LOCAL service %s", candidateRule.Key(), candidateServiceName)
	} else {
		candidatePorts = s.extractPortsFromService(*candidateTargetService)
		candidateServiceName = candidateTargetService.Key()
		klog.Infof("    üîç CANDIDATE RULE: %s uses TARGET service %s", candidateRule.Key(), candidateServiceName)
	}

	var candidatePortStrs []string
	for _, p := range candidatePorts {
		candidatePortStrs = append(candidatePortStrs, fmt.Sprintf("%s/%s", p.Port, p.Protocol))
	}
	klog.Infof("    üîç CANDIDATE SERVICE: %s has %d ports: %v",
		candidateServiceName, len(candidatePorts), candidatePortStrs)

	// üö® –ï—Å–ª–∏ candidate —Ç–æ–∂–µ –Ω–µ –∏–º–µ–µ—Ç –ø–æ—Ä—Ç–æ–≤ ‚Üí –Ω–µ contributing
	if len(candidatePorts) == 0 {
		klog.Infof("  ‚ùå CONTRIBUTES: Candidate service %s has 0 ports ‚Üí NOT contributing", candidateServiceName)
		return false, nil, nil
	}

	klog.Infof("  ‚úÖ CONTRIBUTES: Candidate service %s has %d ports ‚Üí can contribute",
		candidateServiceName, len(candidatePorts))

	// üéØ –§–ò–ù–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï
	klog.Infof("üéØ CONTRIBUTES: FINAL DECISION for rule %s:", candidateRule.Key())
	klog.Infof("    ‚úÖ AG pairs intersect: %v", intersectedPairs)
	klog.Infof("    ‚úÖ Current service %s has %d ports", currentServiceName, len(currentServicePorts))
	klog.Infof("    ‚úÖ Candidate service %s has %d ports", candidateServiceName, len(candidatePorts))
	klog.Infof("    ‚úÖ Will contribute %d ports from %s: %s",
		len(candidatePorts), candidateServiceName, strings.Join(candidatePortStrs, ","))

	return true, candidatePorts, nil
}

// getServicesForRule –ø–æ–ª—É—á–∞–µ—Ç —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è RuleS2S (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ K8s –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—É)
func (s *NetguardService) getServicesForRule(
	ctx context.Context,
	reader ports.Reader,
	rule models.RuleS2S,
) (*models.Service, *models.Service, error) {
	// –ü–æ–ª—É—á–∞–µ–º local service —á–µ—Ä–µ–∑ ServiceAlias
	localServiceAlias, err := reader.GetServiceAliasByID(ctx, rule.ServiceLocalRef.ResourceIdentifier)
	if err != nil {
		return nil, nil, errors.Wrapf(err, "failed to get local service alias %s", rule.ServiceLocalRef.Key())
	}

	localService, err := reader.GetServiceByID(ctx, localServiceAlias.ServiceRef.ResourceIdentifier)
	if err != nil {
		return nil, nil, errors.Wrapf(err, "failed to get local service %s", localServiceAlias.ServiceRef.Key())
	}

	// –ü–æ–ª—É—á–∞–µ–º target service —á–µ—Ä–µ–∑ ServiceAlias
	targetServiceAlias, err := reader.GetServiceAliasByID(ctx, rule.ServiceRef.ResourceIdentifier)
	if err != nil {
		return nil, nil, errors.Wrapf(err, "failed to get target service alias %s", rule.ServiceRef.Key())
	}

	targetService, err := reader.GetServiceByID(ctx, targetServiceAlias.ServiceRef.ResourceIdentifier)
	if err != nil {
		return nil, nil, errors.Wrapf(err, "failed to get target service %s", targetServiceAlias.ServiceRef.Key())
	}

	return localService, targetService, nil
}

// servicesHaveSameAddressGroups –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∏–º–µ—é—Ç –ª–∏ —Å–µ—Ä–≤–∏—Å—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ AddressGroups
func (s *NetguardService) servicesHaveSameAddressGroups(
	service1 models.Service,
	service2 models.Service,
) bool {
	if len(service1.AddressGroups) != len(service2.AddressGroups) {
		return false
	}

	agMap := make(map[string]bool)
	for _, ag := range service1.AddressGroups {
		key := ag.Key()
		agMap[key] = true
	}

	for _, ag := range service2.AddressGroups {
		key := ag.Key()
		if !agMap[key] {
			return false
		}
	}

	return true
}

// extractPortsFromService –∏–∑–≤–ª–µ–∫–∞–µ—Ç –ø–æ—Ä—Ç—ã –∏–∑ —Å–µ—Ä–≤–∏—Å–∞ —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞—Ö
func (s *NetguardService) extractPortsFromService(service models.Service) []models.IngressPort {
	return service.IngressPorts
}

// aggregatePortsWithProtocol –∞–≥—Ä–µ–≥–∏—Ä—É–µ—Ç –ø–æ—Ä—Ç—ã –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞
func (s *NetguardService) aggregatePortsWithProtocol(
	contributingRules []ContributingRule,
	protocol models.TransportProtocol,
) []string {
	klog.Infof("üîÄ PORT_AGGREGATION: Starting aggregation for protocol %s with %d contributing rules",
		protocol, len(contributingRules))

	portSet := make(map[string]bool)

	for i, rule := range contributingRules {
		// –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ—Ä—Ç—ã –ø–æ –ø—Ä–æ—Ç–æ–∫–æ–ª—É
		var protocolPorts []string
		for _, port := range rule.Ports {
			if port.Protocol == protocol {
				protocolPorts = append(protocolPorts, port.Port)
			}
		}

		klog.Infof("  üîÄ RULE[%d]: %s has %d total ports, %d %s ports: %v",
			i, rule.RuleS2S.Key(), len(rule.Ports), len(protocolPorts), protocol, protocolPorts)

		for j, port := range protocolPorts {
			portSet[port] = true
			klog.Infof("    üîÄ PORT[%d]: %s ‚Üí added to aggregation", j, port)
		}
	}

	var aggregatedPorts []string
	for port := range portSet {
		aggregatedPorts = append(aggregatedPorts, port)
	}

	sort.Strings(aggregatedPorts)

	klog.Infof("üéØ PORT_AGGREGATION: Final aggregated ports for %s: %d ports ‚Üí %v",
		protocol, len(aggregatedPorts), aggregatedPorts)

	return aggregatedPorts
}
